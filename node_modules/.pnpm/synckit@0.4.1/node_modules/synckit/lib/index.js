import { __awaiter } from "tslib";
import { execSync } from 'child_process';
import { tmpdir as _tmpdir } from 'os';
import path from 'path';
import fs from 'fs';
import { createRequire } from 'module';
import { v4 as uuid } from 'uuid';
export * from './types.js';
/**
 * @link https://github.com/sindresorhus/temp-dir/blob/main/index.js#L9
 */
export const tmpdir = fs.realpathSync(_tmpdir());
let workerThreads;
const cjsRequire = 
/* istanbul ignore next */
typeof require === 'undefined' ? createRequire(import.meta.url) : require;
try {
    workerThreads = cjsRequire('worker_threads');
    /* istanbul ignore if */
    if (typeof workerThreads.receiveMessageOnPort !== 'function') {
        workerThreads = undefined;
    }
}
catch (_a) { }
/* istanbul ignore if */
if (!workerThreads) {
    console.warn('[synckit]: `worker_threads` or `receiveMessageOnPort` is not available in current environment, `Node >= 12` is required');
}
const { SYNCKIT_WORKER_THREADS, SYNCKIT_BUFFER_SIZE, SYNCKIT_TIMEOUT, SYNCKIT_TS_ESM, } = process.env;
export const useWorkerThreads = !!workerThreads &&
    (!SYNCKIT_WORKER_THREADS || !['0', 'false'].includes(SYNCKIT_WORKER_THREADS));
const TS_USE_ESM = !!SYNCKIT_TS_ESM && ['1', 'true'].includes(SYNCKIT_TS_ESM);
export const DEFAULT_BUFFER_SIZE = SYNCKIT_BUFFER_SIZE
    ? +SYNCKIT_BUFFER_SIZE
    : undefined;
export const DEFAULT_TIMEOUT = SYNCKIT_TIMEOUT ? +SYNCKIT_TIMEOUT : undefined;
export const DEFAULT_WORKER_BUFFER_SIZE = DEFAULT_BUFFER_SIZE || 1024;
const syncFnCache = new Map();
export function createSyncFn(workerPath, bufferSize, timeout = DEFAULT_TIMEOUT) {
    if (!path.isAbsolute(workerPath)) {
        throw new Error('`workerPath` must be absolute');
    }
    const cachedSyncFn = syncFnCache.get(workerPath);
    if (cachedSyncFn) {
        return cachedSyncFn;
    }
    const syncFn = (useWorkerThreads ? startWorkerThread : startChildProcess)(workerPath, bufferSize, timeout);
    syncFnCache.set(workerPath, syncFn);
    return syncFn;
}
function startChildProcess(workerPath, bufferSize = DEFAULT_BUFFER_SIZE, timeout) {
    const executor = workerPath.endsWith('.ts')
        ? TS_USE_ESM
            ? 'node --loader ts-node/esm'
            : 'ts-node'
        : 'node';
    return (...args) => {
        const filename = path.resolve(tmpdir, `synckit-${uuid()}.json`);
        fs.writeFileSync(filename, JSON.stringify(args));
        const command = `${executor} ${workerPath} ${filename}`;
        try {
            execSync(command, {
                stdio: 'inherit',
                maxBuffer: bufferSize,
                timeout,
            });
            const { result, error } = JSON.parse(fs.readFileSync(filename, 'utf8'));
            if (error) {
                throw typeof error === 'object' && 'message' in error
                    ? // eslint-disable-next-line unicorn/error-message
                        Object.assign(new Error(), error)
                    : error;
            }
            return result;
        }
        finally {
            fs.unlinkSync(filename);
        }
    };
}
const throwError = (msg) => {
    throw new Error(msg);
};
function startWorkerThread(workerPath, bufferSize = DEFAULT_WORKER_BUFFER_SIZE, timeout) {
    const { MessageChannel, Worker } = workerThreads;
    const { port1: mainPort, port2: workerPort } = new MessageChannel();
    const isTs = workerPath.endsWith('.ts');
    const worker = new Worker(isTs
        ? TS_USE_ESM
            ? throwError('Native esm in `.ts` file is not supported yet, please use `.cjs` instead')
            : `require('ts-node/register');require('${workerPath}')`
        : workerPath, {
        eval: isTs,
        workerData: { workerPort },
        transferList: [workerPort],
        execArgv: [],
    });
    let nextID = 0;
    const syncFn = (...args) => {
        const id = nextID++;
        const sharedBuffer = new SharedArrayBuffer(bufferSize);
        const sharedBufferView = new Int32Array(sharedBuffer);
        const msg = { sharedBuffer, id, args };
        worker.postMessage(msg);
        const status = Atomics.wait(sharedBufferView, 0, 0, timeout);
        /* istanbul ignore if */
        if (!['ok', 'not-equal'].includes(status)) {
            throw new Error('Internal error: Atomics.wait() failed: ' + status);
        }
        const { id: id2, result, error, } = workerThreads.receiveMessageOnPort(mainPort)
            .message;
        /* istanbul ignore if */
        if (id !== id2) {
            throw new Error(`Internal error: Expected id ${id} but got id ${id2}`);
        }
        if (error) {
            throw error;
        }
        return result;
    };
    worker.unref();
    return syncFn;
}
export function runAsWorker(fn) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!(workerThreads === null || workerThreads === void 0 ? void 0 : workerThreads.workerData)) {
            const filename = process.argv[2];
            const content = fs.readFileSync(filename, 'utf8');
            const args = JSON.parse(content);
            let msg;
            try {
                msg = { result: yield fn(...args) };
            }
            catch (err) {
                msg = {
                    error: err instanceof Error
                        ? Object.assign(Object.assign({}, err), { name: err.name, message: err.message, stack: err.stack }) : err,
                };
            }
            fs.writeFileSync(filename, JSON.stringify(msg));
            return;
        }
        /* istanbul ignore next */
        const { workerPort } = workerThreads.workerData;
        /* istanbul ignore next */
        workerThreads.parentPort.on('message', ({ sharedBuffer, id, args }) => {
            // eslint-disable-next-line @typescript-eslint/no-floating-promises
            ;
            (() => __awaiter(this, void 0, void 0, function* () {
                const sharedBufferView = new Int32Array(sharedBuffer);
                let msg;
                try {
                    msg = { id, result: yield fn(...args) };
                }
                catch (error) {
                    msg = {
                        id,
                        error,
                    };
                }
                workerPort.postMessage(msg);
                Atomics.add(sharedBufferView, 0, 1);
                Atomics.notify(sharedBufferView, 0);
            }))();
        });
    });
}
//# sourceMappingURL=index.js.map