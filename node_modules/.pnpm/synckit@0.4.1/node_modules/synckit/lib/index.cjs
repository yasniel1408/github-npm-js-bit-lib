'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var child_process = require('child_process');
var os = require('os');
var path = require('path');
var fs = require('fs');
var module$1 = require('module');
var uuid = require('uuid');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var path__default = /*#__PURE__*/_interopDefaultLegacy(path);
var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const import_meta = {};
const tmpdir = fs__default['default'].realpathSync(os.tmpdir());
let workerThreads;
const cjsRequire = typeof require === "undefined" ? module$1.createRequire(import_meta.url) : require;
try {
  workerThreads = cjsRequire("worker_threads");
  if (typeof workerThreads.receiveMessageOnPort !== "function") {
    workerThreads = void 0;
  }
} catch (e) {
}
if (!workerThreads) {
  console.warn("[synckit]: `worker_threads` or `receiveMessageOnPort` is not available in current environment, `Node >= 12` is required");
}
const {
  SYNCKIT_WORKER_THREADS,
  SYNCKIT_BUFFER_SIZE,
  SYNCKIT_TIMEOUT,
  SYNCKIT_TS_ESM
} = process.env;
const useWorkerThreads = !!workerThreads && (!SYNCKIT_WORKER_THREADS || !["0", "false"].includes(SYNCKIT_WORKER_THREADS));
const TS_USE_ESM = !!SYNCKIT_TS_ESM && ["1", "true"].includes(SYNCKIT_TS_ESM);
const DEFAULT_BUFFER_SIZE = SYNCKIT_BUFFER_SIZE ? +SYNCKIT_BUFFER_SIZE : void 0;
const DEFAULT_TIMEOUT = SYNCKIT_TIMEOUT ? +SYNCKIT_TIMEOUT : void 0;
const DEFAULT_WORKER_BUFFER_SIZE = DEFAULT_BUFFER_SIZE || 1024;
const syncFnCache = new Map();
function createSyncFn(workerPath, bufferSize, timeout = DEFAULT_TIMEOUT) {
  if (!path__default['default'].isAbsolute(workerPath)) {
    throw new Error("`workerPath` must be absolute");
  }
  const cachedSyncFn = syncFnCache.get(workerPath);
  if (cachedSyncFn) {
    return cachedSyncFn;
  }
  const syncFn = (useWorkerThreads ? startWorkerThread : startChildProcess)(workerPath, bufferSize, timeout);
  syncFnCache.set(workerPath, syncFn);
  return syncFn;
}
function startChildProcess(workerPath, bufferSize = DEFAULT_BUFFER_SIZE, timeout) {
  const executor = workerPath.endsWith(".ts") ? TS_USE_ESM ? "node --loader ts-node/esm" : "ts-node" : "node";
  return (...args) => {
    const filename = path__default['default'].resolve(tmpdir, `synckit-${uuid.v4()}.json`);
    fs__default['default'].writeFileSync(filename, JSON.stringify(args));
    const command = `${executor} ${workerPath} ${filename}`;
    try {
      child_process.execSync(command, {
        stdio: "inherit",
        maxBuffer: bufferSize,
        timeout
      });
      const { result, error } = JSON.parse(fs__default['default'].readFileSync(filename, "utf8"));
      if (error) {
        throw typeof error === "object" && "message" in error ? Object.assign(new Error(), error) : error;
      }
      return result;
    } finally {
      fs__default['default'].unlinkSync(filename);
    }
  };
}
const throwError = (msg) => {
  throw new Error(msg);
};
function startWorkerThread(workerPath, bufferSize = DEFAULT_WORKER_BUFFER_SIZE, timeout) {
  const { MessageChannel, Worker } = workerThreads;
  const { port1: mainPort, port2: workerPort } = new MessageChannel();
  const isTs = workerPath.endsWith(".ts");
  const worker = new Worker(isTs ? TS_USE_ESM ? throwError("Native esm in `.ts` file is not supported yet, please use `.cjs` instead") : `require('ts-node/register');require('${workerPath}')` : workerPath, {
    eval: isTs,
    workerData: { workerPort },
    transferList: [workerPort],
    execArgv: []
  });
  let nextID = 0;
  const syncFn = (...args) => {
    const id = nextID++;
    const sharedBuffer = new SharedArrayBuffer(bufferSize);
    const sharedBufferView = new Int32Array(sharedBuffer);
    const msg = { sharedBuffer, id, args };
    worker.postMessage(msg);
    const status = Atomics.wait(sharedBufferView, 0, 0, timeout);
    if (!["ok", "not-equal"].includes(status)) {
      throw new Error("Internal error: Atomics.wait() failed: " + status);
    }
    const {
      id: id2,
      result,
      error
    } = workerThreads.receiveMessageOnPort(mainPort).message;
    if (id !== id2) {
      throw new Error(`Internal error: Expected id ${id} but got id ${id2}`);
    }
    if (error) {
      throw error;
    }
    return result;
  };
  worker.unref();
  return syncFn;
}
function runAsWorker(fn) {
  return __async(this, null, function* () {
    if (!(workerThreads == null ? void 0 : workerThreads.workerData)) {
      const filename = process.argv[2];
      const content = fs__default['default'].readFileSync(filename, "utf8");
      const args = JSON.parse(content);
      let msg;
      try {
        msg = { result: yield fn(...args) };
      } catch (err) {
        msg = {
          error: err instanceof Error ? __spreadProps(__spreadValues({}, err), { name: err.name, message: err.message, stack: err.stack }) : err
        };
      }
      fs__default['default'].writeFileSync(filename, JSON.stringify(msg));
      return;
    }
    const { workerPort } = workerThreads.workerData;
    workerThreads.parentPort.on("message", ({ sharedBuffer, id, args }) => {
      (() => __async(this, null, function* () {
        const sharedBufferView = new Int32Array(sharedBuffer);
        let msg;
        try {
          msg = { id, result: yield fn(...args) };
        } catch (error) {
          msg = {
            id,
            error
          };
        }
        workerPort.postMessage(msg);
        Atomics.add(sharedBufferView, 0, 1);
        Atomics.notify(sharedBufferView, 0);
      }))();
    });
  });
}

exports.DEFAULT_BUFFER_SIZE = DEFAULT_BUFFER_SIZE;
exports.DEFAULT_TIMEOUT = DEFAULT_TIMEOUT;
exports.DEFAULT_WORKER_BUFFER_SIZE = DEFAULT_WORKER_BUFFER_SIZE;
exports.createSyncFn = createSyncFn;
exports.runAsWorker = runAsWorker;
exports.tmpdir = tmpdir;
exports.useWorkerThreads = useWorkerThreads;
