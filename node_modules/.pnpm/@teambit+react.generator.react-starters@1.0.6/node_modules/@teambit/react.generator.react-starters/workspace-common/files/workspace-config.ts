import { WorkspaceContext } from '@teambit/generator';
import {
  getWorkspaceConfigTemplateParsed,
  stringifyWorkspaceConfig,
} from '@teambit/config';
import { assign } from 'comment-json';
import { DEFAULT_SCOPE_NAME, FORKED_ENV_NAME } from '../constants';

export async function workspaceConfig(
  { name, defaultScope, aspectComponent }: WorkspaceContext,
  extraConfig?: Record<string, any>
) {
  const scope = defaultScope || DEFAULT_SCOPE_NAME;
  const envId = aspectComponent!.id.toStringWithoutVersion();
  /**
   * a ws that was generated by the react-env should use the forked env
   */
  const generatorEnv =
    envId === 'teambit.react/react-env' ? `${scope}/${FORKED_ENV_NAME}` : envId;
  const configParsed = await getWorkspaceConfigTemplateParsed();
  configParsed['teambit.workspace/workspace'].name = name;
  configParsed['teambit.workspace/workspace'].defaultScope = scope;
  configParsed["teambit.workspace/workspace"].resolveEnvsFromRoots = true;
  configParsed['teambit.dependencies/dependency-resolver'].packageManager =
    'teambit.dependencies/pnpm';
  configParsed['teambit.dependencies/dependency-resolver'].rootComponents =
    true;
  configParsed['teambit.dependencies/dependency-resolver'].policy = {
    dependencies: {
      '@teambit/dependencies.modules.packages-excluder': '^0.0.68',
      eslint: '^7.28.0',
    },
    peerDependencies: {},
  };
  configParsed['teambit.generator/generator'] = {
    envs: [generatorEnv],
  };

  delete configParsed['teambit.workspace/variants'];

  let configMerged = extraConfig
    ? assign(configParsed, extraConfig)
    : configParsed;

  return stringifyWorkspaceConfig(configMerged);
}
