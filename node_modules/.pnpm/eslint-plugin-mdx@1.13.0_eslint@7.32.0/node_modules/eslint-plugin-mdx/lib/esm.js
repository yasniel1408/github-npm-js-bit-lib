import { __assign, __spreadArray } from 'tslib';
import { arrayify, last, isJsxNode, DEFAULT_EXTENSIONS, MARKDOWN_EXTENSIONS } from 'eslint-mdx';
import { version } from 'eslint/package.json';
import { processors } from 'eslint-plugin-markdown';
import esLintNoUnusedExpressions from 'eslint/lib/rules/no-unused-expressions';
import path from 'path';
import { createSyncFn } from 'synckit';
import vfile from 'vfile';
import fs from 'fs';
import { cosmiconfigSync } from 'cosmiconfig';
import remarkMdx from 'remark-mdx';
import remarkParse from 'remark-parse';
import remarkStringify from 'remark-stringify';
import unified from 'unified';

var base = {
    parser: 'eslint-mdx',
    plugins: ['mdx'],
    processor: 'mdx/remark',
};

var codeBlocks = {
    parserOptions: {
        ecmaFeatures: {
            // Adding a "use strict" directive at the top of
            // every code block is tedious and distracting, so
            // opt into strict mode parsing without the
            // directive.
            impliedStrict: true,
        },
    },
    rules: {
        // The Markdown parser automatically trims trailing
        // newlines from code blocks.
        'eol-last': 'off',
        // In code snippets and examples, these rules are often
        // counterproductive to clarity and brevity.
        'no-undef': 'off',
        'no-unused-expressions': 'off',
        'no-unused-vars': 'off',
        'padded-blocks': 'off',
        // Adding a "use strict" directive at the top of every
        // code block is tedious and distracting. The config
        // opts into strict mode parsing without the directive.
        strict: 'off',
        // The processor will not receive a Unicode Byte Order
        // Mark from the Markdown parser.
        'unicode-bom': 'off',
    },
};

var isReactPluginAvailable = false;
try {
    // eslint-disable-next-line node/no-extraneous-require
    require.resolve('eslint-plugin-react');
    isReactPluginAvailable = true;
}
catch (_a) { }
var overrides$1 = __assign(__assign({}, base), { globals: {
        React: false,
    }, plugins: arrayify(base.plugins, 
    /* istanbul ignore next */
    isReactPluginAvailable ? 'react' : null), rules: {
        'lines-between-class-members': 0,
        'react/jsx-no-undef': 
        /* istanbul ignore next */
        isReactPluginAvailable
            ? [
                2,
                {
                    allowGlobals: true,
                },
            ]
            : 0,
        'react/react-in-jsx-scope': 0,
    } });

var minorVersion = +version.split('.').slice(0, 2).join('.');
var recommended = __assign(__assign({}, base), { rules: {
        'mdx/no-jsx-html-comments': 2,
        'mdx/no-unused-expressions': 2,
        'mdx/remark': 1,
        'no-unused-expressions': 0,
    } });
var OVERRIDES_AVAILABLE_VERSION = 6.4;
// overrides in npm pkg is supported after v6.4.0
// istanbul ignore else
if (minorVersion >= OVERRIDES_AVAILABLE_VERSION) {
    var overrides = [
        {
            files: '*.mdx',
            extends: 'plugin:mdx/overrides',
        },
        {
            files: '**/*.{md,mdx}/**',
            extends: 'plugin:mdx/code-blocks',
        },
    ];
    try {
        // eslint-disable-next-line node/no-extraneous-require
        require.resolve('prettier');
        // eslint-disable-next-line node/no-extraneous-require
        require.resolve('eslint-plugin-prettier');
        overrides.push({
            files: '*.md',
            rules: {
                'prettier/prettier': [
                    2,
                    {
                        parser: 'markdown',
                    },
                ],
            },
        }, {
            files: '*.mdx',
            rules: {
                'prettier/prettier': [
                    2,
                    {
                        parser: 'mdx',
                    },
                ],
            },
        });
    }
    catch (_a) { }
    Object.assign(recommended, {
        overrides: overrides,
    });
}

/* istanbul ignore file */
var configs = {
    base: base,
    'code-blocks': codeBlocks,
    codeBlocks: codeBlocks,
    overrides: overrides$1,
    recommended: recommended,
};

var getGlobals = function (sources, initialGlobals) {
    if (initialGlobals === void 0) { initialGlobals = {}; }
    return (Array.isArray(sources)
        ? sources
        : Object.keys(sources)).reduce(function (globals, source) {
        var _a;
        return Object.assign(globals, (_a = {},
            _a[source] = false,
            _a));
    }, initialGlobals);
};

var DEFAULT_LANGUAGE_MAPPER = {
    javascript: 'js',
    javascriptreact: 'jsx',
    typescript: 'ts',
    typescriptreact: 'tsx',
    markdown: 'md',
    mdown: 'md',
    mkdn: 'md',
};
function getShortLang(filename, languageMapper) {
    var language = last(filename.split('.'));
    if (languageMapper === false) {
        return language;
    }
    languageMapper = __assign(__assign({}, DEFAULT_LANGUAGE_MAPPER), languageMapper);
    var lang = language.toLowerCase();
    return languageMapper[language] || languageMapper[lang] || lang;
}

/**
 * based on @link https://github.com/sveltejs/eslint-plugin-svelte3/blob/master/src/processor_options.js
 */
var processorOptions = {};
// find Linter instance
var linterPath = Object.keys(require.cache).find(function (path) {
    return /([/\\])eslint\1lib(?:\1linter){2}\.js$/.test(path);
});
/* istanbul ignore if */
if (!linterPath) {
    throw new Error('Could not find ESLint Linter in require cache');
}
// eslint-disable-next-line @typescript-eslint/consistent-type-imports, @typescript-eslint/no-require-imports, @typescript-eslint/no-var-requires
var ESLinter = require(linterPath).Linter;
// patch Linter#verify
// eslint-disable-next-line @typescript-eslint/unbound-method
var verify = ESLinter.prototype.verify;
ESLinter.prototype.verify = function (code, config, options) {
    // fetch settings
    var settings = ((config &&
        (typeof config.extractConfig === 'function'
            ? config.extractConfig(
            /* istanbul ignore next */
            typeof options === 'undefined' || typeof options === 'string'
                ? options
                : options.filename)
            : config).settings) ||
        {});
    processorOptions.lintCodeBlocks = settings['mdx/code-blocks'] === true;
    processorOptions.languageMapper = settings['mdx/language-mapper'];
    // call original Linter#verify
    return verify.call(this, code, config, options);
};

var remark$1 = {
    supportsAutofix: true,
    preprocess: function (text, filename) {
        if (!processorOptions.lintCodeBlocks) {
            return [text];
        }
        return __spreadArray([
            text
        ], processors.markdown
            .preprocess(text, filename)
            .map(function (_a) {
            var text = _a.text, filename = _a.filename;
            return ({
                text: text,
                filename: filename.slice(0, filename.lastIndexOf('.')) +
                    '.' +
                    getShortLang(filename, processorOptions.languageMapper),
            });
        }));
    },
    postprocess: function (_a, filename) {
        var mdxMessages = _a[0], markdownMessages = _a.slice(1);
        return __spreadArray(__spreadArray([], mdxMessages), processors.markdown.postprocess(markdownMessages, filename)).map(function (lintMessage) {
            var message = lintMessage.message, eslintRuleId = lintMessage.ruleId, eslintSeverity = lintMessage.severity;
            if (eslintRuleId !== 'mdx/remark') {
                return lintMessage;
            }
            var _a = JSON.parse(message), source = _a.source, ruleId = _a.ruleId, reason = _a.reason, severity = _a.severity;
            return __assign(__assign({}, lintMessage), { ruleId: source + "-" + ruleId, message: reason, severity: Math.max(eslintSeverity, severity) });
        });
    },
};

var remark$2 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  remark: remark$1
});

var noJsxHtmlComments = {
    meta: {
        type: 'problem',
        docs: {
            description: 'Forbid invalid html style comments in jsx block',
            category: 'SyntaxError',
            recommended: true,
        },
        messages: {
            jsxHtmlComments: 'html style comments are invalid in jsx: {{ origin }}',
        },
        fixable: 'code',
    },
    create: function (context) {
        return {
            ExpressionStatement: function (node) {
                var invalidNodes = context.parserServices.JSXElementsWithHTMLComments;
                if (!isJsxNode(node.expression) ||
                    node.parent.type !== 'Program' ||
                    !invalidNodes ||
                    invalidNodes.length === 0) {
                    return;
                }
                var invalidNode = invalidNodes.shift();
                if (invalidNode.data.inline) {
                    return;
                }
                var comments = invalidNode.data.comments;
                var _loop_1 = function (fixed, loc, origin) {
                    context.report({
                        messageId: 'jsxHtmlComments',
                        data: {
                            origin: origin,
                        },
                        loc: loc,
                        node: node,
                        fix: function (fixer) {
                            return fixer.replaceTextRange([loc.start.offset, loc.end.offset], fixed);
                        },
                    });
                };
                for (var _i = 0, comments_1 = comments; _i < comments_1.length; _i++) {
                    var _a = comments_1[_i], fixed = _a.fixed, loc = _a.loc, origin = _a.origin;
                    _loop_1(fixed, loc, origin);
                }
            },
        };
    },
};

/// <reference path="../../typings.d.ts" />
var noUnusedExpressions = __assign(__assign({}, esLintNoUnusedExpressions), { create: function (context) {
        var esLintRuleListener = esLintNoUnusedExpressions.create(context);
        return {
            ExpressionStatement: function (node) {
                if (isJsxNode(node.expression) && node.parent.type === 'Program') {
                    return;
                }
                esLintRuleListener.ExpressionStatement(node);
            },
        };
    } });

var requirePkg = function (plugin, prefix, filePath) {
    if (filePath && /^\.\.?([/\\]|$)/.test(plugin)) {
        plugin = path.resolve(path.dirname(filePath), plugin);
    }
    prefix = prefix.endsWith('-') ? prefix : prefix + '-';
    var packages = [
        plugin,
        plugin.startsWith('@')
            ? plugin.replace('/', '/' + prefix)
            : prefix + plugin,
    ];
    var error;
    for (var _i = 0, packages_1 = packages; _i < packages_1.length; _i++) {
        var pkg = packages_1[_i];
        try {
            // eslint-disable-next-line @typescript-eslint/no-require-imports, @typescript-eslint/no-var-requires
            return require(pkg);
        }
        catch (err) {
            if (!error) {
                error = err;
            }
        }
    }
    throw error;
};
/**
 * Given a filepath, get the nearest path that is a regular file.
 * The filepath provided by eslint may be a virtual filepath rather than a file
 * on disk. This attempts to transform a virtual path into an on-disk path
 */
var getPhysicalFilename = function (filename) {
    try {
        if (fs.statSync(filename).isFile()) {
            return filename;
        }
    }
    catch (err) {
        // https://github.com/eslint/eslint/issues/11989
        if (err.code === 'ENOTDIR') {
            return getPhysicalFilename(path.dirname(filename));
        }
    }
    return filename;
};
var remarkProcessor = unified().use(remarkParse).freeze();
var explorer = cosmiconfigSync('remark', {
    packageProp: 'remarkConfig',
});
// @internal - exported for testing
var processorCache = new Map();
// eslint-disable-next-line sonarjs/cognitive-complexity
var getRemarkProcessor = function (searchFrom, isMdx) {
    var initCacheKey = String(isMdx) + "-" + searchFrom;
    var cachedProcessor = processorCache.get(initCacheKey);
    if (cachedProcessor) {
        return cachedProcessor;
    }
    var result = explorer.search(searchFrom);
    var cacheKey = result ? String(isMdx) + "-" + result.filepath : '';
    cachedProcessor = processorCache.get(cacheKey);
    if (cachedProcessor) {
        return cachedProcessor;
    }
    if (result) {
        /* istanbul ignore next */
        var _a = (result.config ||
            {}), _b = _a.plugins, plugins = _b === void 0 ? [] : _b, settings = _a.settings;
        // disable this rule automatically since we already have a parser option `extensions`
        // only disable this plugin if there are at least one plugin enabled
        // otherwise it is redundant
        /* istanbul ignore else */
        if (plugins.length > 0) {
            try {
                // eslint-disable-next-line node/no-extraneous-require
                plugins.push([require.resolve('remark-lint-file-extension'), false]);
            }
            catch (_c) {
                // just ignore if the package does not exist
            }
        }
        var initProcessor = remarkProcessor()
            .use({ settings: settings })
            .use(remarkStringify);
        if (isMdx) {
            initProcessor.use(remarkMdx);
        }
        cachedProcessor = plugins
            .reduce(function (processor, pluginWithSettings) {
            var _a = arrayify(pluginWithSettings), plugin = _a[0], pluginSettings = _a.slice(1);
            return processor.use.apply(processor, __spreadArray([
                /* istanbul ignore next */
                typeof plugin === 'string'
                    ? requirePkg(plugin, 'remark', result.filepath)
                    : plugin], pluginSettings));
        }, initProcessor)
            .freeze();
    }
    else {
        var initProcessor = remarkProcessor().use(remarkStringify);
        if (isMdx) {
            initProcessor.use(remarkMdx);
        }
        cachedProcessor = initProcessor.freeze();
    }
    processorCache
        .set(initCacheKey, cachedProcessor)
        .set(cacheKey, cachedProcessor);
    return cachedProcessor;
};

var processSync = createSyncFn(require.resolve('../worker'));
var brokenCache = new WeakMap();
var remark = {
    meta: {
        type: 'layout',
        docs: {
            description: 'Linter integration with remark plugins',
            category: 'Stylistic Issues',
            recommended: true,
        },
        fixable: 'code',
    },
    create: function (context) {
        var filename = context.getFilename();
        var extname = path.extname(filename);
        var sourceCode = context.getSourceCode();
        var options = context.parserOptions;
        var isMdx = DEFAULT_EXTENSIONS.concat(options.extensions || []).includes(extname);
        var isMarkdown = MARKDOWN_EXTENSIONS.concat(options.markdownExtensions || []).includes(extname);
        return {
            // eslint-disable-next-line sonarjs/cognitive-complexity
            Program: function (node) {
                /* istanbul ignore if */
                if (!isMdx && !isMarkdown) {
                    return;
                }
                var physicalFilename = getPhysicalFilename(filename);
                var sourceText = sourceCode.getText(node);
                var remarkProcessor = getRemarkProcessor(physicalFilename, isMdx);
                var fileOptions = {
                    path: filename,
                    contents: sourceText,
                };
                var file = vfile(fileOptions);
                var fixedText;
                var broken = brokenCache.get(remarkProcessor);
                if (broken) {
                    var _a = processSync(fileOptions, physicalFilename, isMdx), messages = _a.messages, content = _a.content;
                    file.messages = messages;
                    fixedText = content;
                }
                else {
                    try {
                        remarkProcessor.processSync(file);
                    }
                    catch (err) {
                        /* istanbul ignore else */
                        if (err.message ===
                            '`processSync` finished async. Use `process` instead') {
                            brokenCache.set(remarkProcessor, (broken = true));
                            var _b = processSync(fileOptions, physicalFilename, isMdx), messages = _b.messages, content = _b.content;
                            file.messages = messages;
                            fixedText = content;
                        }
                        else if (!file.messages.includes(err)) {
                            file.message(err).fatal = true;
                        }
                    }
                }
                if (!broken) {
                    fixedText = file.toString();
                }
                fixedText =
                    filename === physicalFilename || sourceText.endsWith('\n')
                        ? fixedText
                        : fixedText.slice(0, -1);
                var fixed = 0;
                for (var _i = 0, _c = file.messages; _i < _c.length; _i++) {
                    var _d = _c[_i], source = _d.source, reason = _d.reason, ruleId = _d.ruleId, fatal = _d.fatal, _e = _d.location, start = _e.start, end = _e.end;
                    // https://github.com/remarkjs/remark-lint/issues/65#issuecomment-220800231
                    /* istanbul ignore next */
                    var severity = fatal ? 2 : fatal == null ? 0 : 1;
                    /* istanbul ignore if */
                    if (!severity) {
                        // should never happen, just for robustness
                        continue;
                    }
                    var message = {
                        reason: reason,
                        source: source,
                        ruleId: ruleId,
                        severity: severity,
                    };
                    context.report({
                        // related to https://github.com/eslint/eslint/issues/14198
                        message: JSON.stringify(message),
                        loc: {
                            // ! eslint ast column is 0-indexed, but unified is 1-indexed
                            start: __assign(__assign({}, start), { column: start.column - 1 }),
                            end: __assign(__assign({}, end), { column: end.column - 1 }),
                        },
                        node: node,
                        fix: fixedText === sourceText
                            ? null
                            : function () {
                                return fixed++
                                    ? null
                                    : {
                                        range: [0, sourceText.length],
                                        text: fixedText,
                                    };
                            },
                    });
                }
            },
        };
    },
};

/* istanbul ignore file */
var rules = {
    'no-jsx-html-comments': noJsxHtmlComments,
    'no-unused-expressions': noUnusedExpressions,
    noJsxHtmlComments: noJsxHtmlComments,
    noUnusedExpressions: noUnusedExpressions,
    remark: remark,
};

export { DEFAULT_LANGUAGE_MAPPER, base, codeBlocks, configs, getGlobals, getPhysicalFilename, getRemarkProcessor, getShortLang, noJsxHtmlComments, noUnusedExpressions, overrides$1 as overrides, processorCache, processorOptions, remark$2 as processors, recommended, remark, remarkProcessor, requirePkg, rules };
