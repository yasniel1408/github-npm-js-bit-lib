import { arrayify, last, isJsxNode, DEFAULT_EXTENSIONS, MARKDOWN_EXTENSIONS } from 'eslint-mdx';
import { version } from 'eslint/package.json';
import { processors } from 'eslint-plugin-markdown';
import esLintNoUnusedExpressions from 'eslint/lib/rules/no-unused-expressions';
import path from 'path';
import { createSyncFn } from 'synckit';
import vfile from 'vfile';
import fs from 'fs';
import { cosmiconfigSync } from 'cosmiconfig';
import remarkMdx from 'remark-mdx';
import remarkParse from 'remark-parse';
import remarkStringify from 'remark-stringify';
import unified from 'unified';

const base = {
    parser: 'eslint-mdx',
    plugins: ['mdx'],
    processor: 'mdx/remark',
};

const codeBlocks = {
    parserOptions: {
        ecmaFeatures: {
            // Adding a "use strict" directive at the top of
            // every code block is tedious and distracting, so
            // opt into strict mode parsing without the
            // directive.
            impliedStrict: true,
        },
    },
    rules: {
        // The Markdown parser automatically trims trailing
        // newlines from code blocks.
        'eol-last': 'off',
        // In code snippets and examples, these rules are often
        // counterproductive to clarity and brevity.
        'no-undef': 'off',
        'no-unused-expressions': 'off',
        'no-unused-vars': 'off',
        'padded-blocks': 'off',
        // Adding a "use strict" directive at the top of every
        // code block is tedious and distracting. The config
        // opts into strict mode parsing without the directive.
        strict: 'off',
        // The processor will not receive a Unicode Byte Order
        // Mark from the Markdown parser.
        'unicode-bom': 'off',
    },
};

let isReactPluginAvailable = false;
try {
    // eslint-disable-next-line node/no-extraneous-require
    require.resolve('eslint-plugin-react');
    isReactPluginAvailable = true;
}
catch (_a) { }
const overrides = Object.assign(Object.assign({}, base), { globals: {
        React: false,
    }, plugins: arrayify(base.plugins, 
    /* istanbul ignore next */
    isReactPluginAvailable ? 'react' : null), rules: {
        'lines-between-class-members': 0,
        'react/jsx-no-undef': 
        /* istanbul ignore next */
        isReactPluginAvailable
            ? [
                2,
                {
                    allowGlobals: true,
                },
            ]
            : 0,
        'react/react-in-jsx-scope': 0,
    } });

const minorVersion = +version.split('.').slice(0, 2).join('.');
const recommended = Object.assign(Object.assign({}, base), { rules: {
        'mdx/no-jsx-html-comments': 2,
        'mdx/no-unused-expressions': 2,
        'mdx/remark': 1,
        'no-unused-expressions': 0,
    } });
const OVERRIDES_AVAILABLE_VERSION = 6.4;
// overrides in npm pkg is supported after v6.4.0
// istanbul ignore else
if (minorVersion >= OVERRIDES_AVAILABLE_VERSION) {
    const overrides = [
        {
            files: '*.mdx',
            extends: 'plugin:mdx/overrides',
        },
        {
            files: '**/*.{md,mdx}/**',
            extends: 'plugin:mdx/code-blocks',
        },
    ];
    try {
        // eslint-disable-next-line node/no-extraneous-require
        require.resolve('prettier');
        // eslint-disable-next-line node/no-extraneous-require
        require.resolve('eslint-plugin-prettier');
        overrides.push({
            files: '*.md',
            rules: {
                'prettier/prettier': [
                    2,
                    {
                        parser: 'markdown',
                    },
                ],
            },
        }, {
            files: '*.mdx',
            rules: {
                'prettier/prettier': [
                    2,
                    {
                        parser: 'mdx',
                    },
                ],
            },
        });
    }
    catch (_a) { }
    Object.assign(recommended, {
        overrides,
    });
}

/* istanbul ignore file */
const configs = {
    base,
    'code-blocks': codeBlocks,
    codeBlocks,
    overrides,
    recommended,
};

const getGlobals = (sources, initialGlobals = {}) => (Array.isArray(sources)
    ? sources
    : Object.keys(sources)).reduce((globals, source) => Object.assign(globals, {
    [source]: false,
}), initialGlobals);

const DEFAULT_LANGUAGE_MAPPER = {
    javascript: 'js',
    javascriptreact: 'jsx',
    typescript: 'ts',
    typescriptreact: 'tsx',
    markdown: 'md',
    mdown: 'md',
    mkdn: 'md',
};
function getShortLang(filename, languageMapper) {
    const language = last(filename.split('.'));
    if (languageMapper === false) {
        return language;
    }
    languageMapper = Object.assign(Object.assign({}, DEFAULT_LANGUAGE_MAPPER), languageMapper);
    const lang = language.toLowerCase();
    return languageMapper[language] || languageMapper[lang] || lang;
}

/**
 * based on @link https://github.com/sveltejs/eslint-plugin-svelte3/blob/master/src/processor_options.js
 */
const processorOptions = {};
// find Linter instance
const linterPath = Object.keys(require.cache).find(path => /([/\\])eslint\1lib(?:\1linter){2}\.js$/.test(path));
/* istanbul ignore if */
if (!linterPath) {
    throw new Error('Could not find ESLint Linter in require cache');
}
// eslint-disable-next-line @typescript-eslint/consistent-type-imports, @typescript-eslint/no-require-imports, @typescript-eslint/no-var-requires
const ESLinter = require(linterPath).Linter;
// patch Linter#verify
// eslint-disable-next-line @typescript-eslint/unbound-method
const { verify } = ESLinter.prototype;
ESLinter.prototype.verify = function (code, config, options) {
    // fetch settings
    const settings = ((config &&
        (typeof config.extractConfig === 'function'
            ? config.extractConfig(
            /* istanbul ignore next */
            typeof options === 'undefined' || typeof options === 'string'
                ? options
                : options.filename)
            : config).settings) ||
        {});
    processorOptions.lintCodeBlocks = settings['mdx/code-blocks'] === true;
    processorOptions.languageMapper = settings['mdx/language-mapper'];
    // call original Linter#verify
    return verify.call(this, code, config, options);
};

const remark$1 = {
    supportsAutofix: true,
    preprocess(text, filename) {
        if (!processorOptions.lintCodeBlocks) {
            return [text];
        }
        return [
            text,
            ...processors.markdown
                .preprocess(text, filename)
                .map(({ text, filename }) => ({
                text,
                filename: filename.slice(0, filename.lastIndexOf('.')) +
                    '.' +
                    getShortLang(filename, processorOptions.languageMapper),
            })),
        ];
    },
    postprocess([mdxMessages, ...markdownMessages], filename) {
        return [
            ...mdxMessages,
            ...processors.markdown.postprocess(markdownMessages, filename),
        ].map(lintMessage => {
            const { message, ruleId: eslintRuleId, severity: eslintSeverity, } = lintMessage;
            if (eslintRuleId !== 'mdx/remark') {
                return lintMessage;
            }
            const { source, ruleId, reason, severity } = JSON.parse(message);
            return Object.assign(Object.assign({}, lintMessage), { ruleId: `${source}-${ruleId}`, message: reason, severity: Math.max(eslintSeverity, severity) });
        });
    },
};

var remark$2 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  remark: remark$1
});

const noJsxHtmlComments = {
    meta: {
        type: 'problem',
        docs: {
            description: 'Forbid invalid html style comments in jsx block',
            category: 'SyntaxError',
            recommended: true,
        },
        messages: {
            jsxHtmlComments: 'html style comments are invalid in jsx: {{ origin }}',
        },
        fixable: 'code',
    },
    create(context) {
        return {
            ExpressionStatement(node) {
                const { JSXElementsWithHTMLComments: invalidNodes, } = context.parserServices;
                if (!isJsxNode(node.expression) ||
                    node.parent.type !== 'Program' ||
                    !invalidNodes ||
                    invalidNodes.length === 0) {
                    return;
                }
                const invalidNode = invalidNodes.shift();
                if (invalidNode.data.inline) {
                    return;
                }
                const comments = invalidNode.data.comments;
                for (const { fixed, loc, origin } of comments) {
                    context.report({
                        messageId: 'jsxHtmlComments',
                        data: {
                            origin,
                        },
                        loc,
                        node,
                        fix(fixer) {
                            return fixer.replaceTextRange([loc.start.offset, loc.end.offset], fixed);
                        },
                    });
                }
            },
        };
    },
};

/// <reference path="../../typings.d.ts" />
const noUnusedExpressions = Object.assign(Object.assign({}, esLintNoUnusedExpressions), { create(context) {
        const esLintRuleListener = esLintNoUnusedExpressions.create(context);
        return {
            ExpressionStatement(node) {
                if (isJsxNode(node.expression) && node.parent.type === 'Program') {
                    return;
                }
                esLintRuleListener.ExpressionStatement(node);
            },
        };
    } });

const requirePkg = (plugin, prefix, filePath) => {
    if (filePath && /^\.\.?([/\\]|$)/.test(plugin)) {
        plugin = path.resolve(path.dirname(filePath), plugin);
    }
    prefix = prefix.endsWith('-') ? prefix : prefix + '-';
    const packages = [
        plugin,
        plugin.startsWith('@')
            ? plugin.replace('/', '/' + prefix)
            : prefix + plugin,
    ];
    let error;
    for (const pkg of packages) {
        try {
            // eslint-disable-next-line @typescript-eslint/no-require-imports, @typescript-eslint/no-var-requires
            return require(pkg);
        }
        catch (err) {
            if (!error) {
                error = err;
            }
        }
    }
    throw error;
};
/**
 * Given a filepath, get the nearest path that is a regular file.
 * The filepath provided by eslint may be a virtual filepath rather than a file
 * on disk. This attempts to transform a virtual path into an on-disk path
 */
const getPhysicalFilename = (filename) => {
    try {
        if (fs.statSync(filename).isFile()) {
            return filename;
        }
    }
    catch (err) {
        // https://github.com/eslint/eslint/issues/11989
        if (err.code === 'ENOTDIR') {
            return getPhysicalFilename(path.dirname(filename));
        }
    }
    return filename;
};
const remarkProcessor = unified().use(remarkParse).freeze();
const explorer = cosmiconfigSync('remark', {
    packageProp: 'remarkConfig',
});
// @internal - exported for testing
const processorCache = new Map();
// eslint-disable-next-line sonarjs/cognitive-complexity
const getRemarkProcessor = (searchFrom, isMdx) => {
    const initCacheKey = `${String(isMdx)}-${searchFrom}`;
    let cachedProcessor = processorCache.get(initCacheKey);
    if (cachedProcessor) {
        return cachedProcessor;
    }
    const result = explorer.search(searchFrom);
    const cacheKey = result ? `${String(isMdx)}-${result.filepath}` : '';
    cachedProcessor = processorCache.get(cacheKey);
    if (cachedProcessor) {
        return cachedProcessor;
    }
    if (result) {
        /* istanbul ignore next */
        const { plugins = [], settings } = (result.config ||
            {});
        // disable this rule automatically since we already have a parser option `extensions`
        // only disable this plugin if there are at least one plugin enabled
        // otherwise it is redundant
        /* istanbul ignore else */
        if (plugins.length > 0) {
            try {
                // eslint-disable-next-line node/no-extraneous-require
                plugins.push([require.resolve('remark-lint-file-extension'), false]);
            }
            catch (_a) {
                // just ignore if the package does not exist
            }
        }
        const initProcessor = remarkProcessor()
            .use({ settings })
            .use(remarkStringify);
        if (isMdx) {
            initProcessor.use(remarkMdx);
        }
        cachedProcessor = plugins
            .reduce((processor, pluginWithSettings) => {
            const [plugin, ...pluginSettings] = arrayify(pluginWithSettings);
            return processor.use(
            /* istanbul ignore next */
            typeof plugin === 'string'
                ? requirePkg(plugin, 'remark', result.filepath)
                : plugin, ...pluginSettings);
        }, initProcessor)
            .freeze();
    }
    else {
        const initProcessor = remarkProcessor().use(remarkStringify);
        if (isMdx) {
            initProcessor.use(remarkMdx);
        }
        cachedProcessor = initProcessor.freeze();
    }
    processorCache
        .set(initCacheKey, cachedProcessor)
        .set(cacheKey, cachedProcessor);
    return cachedProcessor;
};

const processSync = createSyncFn(require.resolve('../worker'));
const brokenCache = new WeakMap();
const remark = {
    meta: {
        type: 'layout',
        docs: {
            description: 'Linter integration with remark plugins',
            category: 'Stylistic Issues',
            recommended: true,
        },
        fixable: 'code',
    },
    create(context) {
        const filename = context.getFilename();
        const extname = path.extname(filename);
        const sourceCode = context.getSourceCode();
        const options = context.parserOptions;
        const isMdx = DEFAULT_EXTENSIONS.concat(options.extensions || []).includes(extname);
        const isMarkdown = MARKDOWN_EXTENSIONS.concat(options.markdownExtensions || []).includes(extname);
        return {
            // eslint-disable-next-line sonarjs/cognitive-complexity
            Program(node) {
                /* istanbul ignore if */
                if (!isMdx && !isMarkdown) {
                    return;
                }
                const physicalFilename = getPhysicalFilename(filename);
                const sourceText = sourceCode.getText(node);
                const remarkProcessor = getRemarkProcessor(physicalFilename, isMdx);
                const fileOptions = {
                    path: filename,
                    contents: sourceText,
                };
                const file = vfile(fileOptions);
                let fixedText;
                let broken = brokenCache.get(remarkProcessor);
                if (broken) {
                    const { messages, content } = processSync(fileOptions, physicalFilename, isMdx);
                    file.messages = messages;
                    fixedText = content;
                }
                else {
                    try {
                        remarkProcessor.processSync(file);
                    }
                    catch (err) {
                        /* istanbul ignore else */
                        if (err.message ===
                            '`processSync` finished async. Use `process` instead') {
                            brokenCache.set(remarkProcessor, (broken = true));
                            const { messages, content } = processSync(fileOptions, physicalFilename, isMdx);
                            file.messages = messages;
                            fixedText = content;
                        }
                        else if (!file.messages.includes(err)) {
                            file.message(err).fatal = true;
                        }
                    }
                }
                if (!broken) {
                    fixedText = file.toString();
                }
                fixedText =
                    filename === physicalFilename || sourceText.endsWith('\n')
                        ? fixedText
                        : fixedText.slice(0, -1);
                let fixed = 0;
                for (const { source, reason, ruleId, fatal, location: { start, end }, } of file.messages) {
                    // https://github.com/remarkjs/remark-lint/issues/65#issuecomment-220800231
                    /* istanbul ignore next */
                    const severity = fatal ? 2 : fatal == null ? 0 : 1;
                    /* istanbul ignore if */
                    if (!severity) {
                        // should never happen, just for robustness
                        continue;
                    }
                    const message = {
                        reason,
                        source,
                        ruleId,
                        severity,
                    };
                    context.report({
                        // related to https://github.com/eslint/eslint/issues/14198
                        message: JSON.stringify(message),
                        loc: {
                            // ! eslint ast column is 0-indexed, but unified is 1-indexed
                            start: Object.assign(Object.assign({}, start), { column: start.column - 1 }),
                            end: Object.assign(Object.assign({}, end), { column: end.column - 1 }),
                        },
                        node,
                        fix: fixedText === sourceText
                            ? null
                            : () => fixed++
                                ? null
                                : {
                                    range: [0, sourceText.length],
                                    text: fixedText,
                                },
                    });
                }
            },
        };
    },
};

/* istanbul ignore file */
const rules = {
    'no-jsx-html-comments': noJsxHtmlComments,
    'no-unused-expressions': noUnusedExpressions,
    noJsxHtmlComments,
    noUnusedExpressions,
    remark,
};

export { DEFAULT_LANGUAGE_MAPPER, base, codeBlocks, configs, getGlobals, getPhysicalFilename, getRemarkProcessor, getShortLang, noJsxHtmlComments, noUnusedExpressions, overrides, processorCache, processorOptions, remark$2 as processors, recommended, remark, remarkProcessor, requirePkg, rules };
