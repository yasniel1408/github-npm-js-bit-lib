"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRemarkProcessor = exports.processorCache = exports.remarkProcessor = exports.getPhysicalFilename = exports.requirePkg = void 0;
const tslib_1 = require("tslib");
const fs_1 = tslib_1.__importDefault(require("fs"));
const path_1 = tslib_1.__importDefault(require("path"));
const cosmiconfig_1 = require("cosmiconfig");
const eslint_mdx_1 = require("eslint-mdx");
const remark_mdx_1 = tslib_1.__importDefault(require("remark-mdx"));
const remark_parse_1 = tslib_1.__importDefault(require("remark-parse"));
const remark_stringify_1 = tslib_1.__importDefault(require("remark-stringify"));
const unified_1 = tslib_1.__importDefault(require("unified"));
const requirePkg = (plugin, prefix, filePath) => {
    if (filePath && /^\.\.?([/\\]|$)/.test(plugin)) {
        plugin = path_1.default.resolve(path_1.default.dirname(filePath), plugin);
    }
    prefix = prefix.endsWith('-') ? prefix : prefix + '-';
    const packages = [
        plugin,
        plugin.startsWith('@')
            ? plugin.replace('/', '/' + prefix)
            : prefix + plugin,
    ];
    let error;
    for (const pkg of packages) {
        try {
            // eslint-disable-next-line @typescript-eslint/no-require-imports, @typescript-eslint/no-var-requires
            return require(pkg);
        }
        catch (err) {
            if (!error) {
                error = err;
            }
        }
    }
    throw error;
};
exports.requirePkg = requirePkg;
/**
 * Given a filepath, get the nearest path that is a regular file.
 * The filepath provided by eslint may be a virtual filepath rather than a file
 * on disk. This attempts to transform a virtual path into an on-disk path
 */
const getPhysicalFilename = (filename) => {
    try {
        if (fs_1.default.statSync(filename).isFile()) {
            return filename;
        }
    }
    catch (err) {
        // https://github.com/eslint/eslint/issues/11989
        if (err.code === 'ENOTDIR') {
            return exports.getPhysicalFilename(path_1.default.dirname(filename));
        }
    }
    return filename;
};
exports.getPhysicalFilename = getPhysicalFilename;
exports.remarkProcessor = unified_1.default().use(remark_parse_1.default).freeze();
const explorer = cosmiconfig_1.cosmiconfigSync('remark', {
    packageProp: 'remarkConfig',
});
// @internal - exported for testing
exports.processorCache = new Map();
// eslint-disable-next-line sonarjs/cognitive-complexity
const getRemarkProcessor = (searchFrom, isMdx) => {
    const initCacheKey = `${String(isMdx)}-${searchFrom}`;
    let cachedProcessor = exports.processorCache.get(initCacheKey);
    if (cachedProcessor) {
        return cachedProcessor;
    }
    const result = explorer.search(searchFrom);
    const cacheKey = result ? `${String(isMdx)}-${result.filepath}` : '';
    cachedProcessor = exports.processorCache.get(cacheKey);
    if (cachedProcessor) {
        return cachedProcessor;
    }
    if (result) {
        /* istanbul ignore next */
        const { plugins = [], settings } = (result.config ||
            {});
        // disable this rule automatically since we already have a parser option `extensions`
        // only disable this plugin if there are at least one plugin enabled
        // otherwise it is redundant
        /* istanbul ignore else */
        if (plugins.length > 0) {
            try {
                // eslint-disable-next-line node/no-extraneous-require
                plugins.push([require.resolve('remark-lint-file-extension'), false]);
            }
            catch (_a) {
                // just ignore if the package does not exist
            }
        }
        const initProcessor = exports.remarkProcessor()
            .use({ settings })
            .use(remark_stringify_1.default);
        if (isMdx) {
            initProcessor.use(remark_mdx_1.default);
        }
        cachedProcessor = plugins
            .reduce((processor, pluginWithSettings) => {
            const [plugin, ...pluginSettings] = eslint_mdx_1.arrayify(pluginWithSettings);
            return processor.use(
            /* istanbul ignore next */
            typeof plugin === 'string'
                ? exports.requirePkg(plugin, 'remark', result.filepath)
                : plugin, ...pluginSettings);
        }, initProcessor)
            .freeze();
    }
    else {
        const initProcessor = exports.remarkProcessor().use(remark_stringify_1.default);
        if (isMdx) {
            initProcessor.use(remark_mdx_1.default);
        }
        cachedProcessor = initProcessor.freeze();
    }
    exports.processorCache
        .set(initCacheKey, cachedProcessor)
        .set(cacheKey, cachedProcessor);
    return cachedProcessor;
};
exports.getRemarkProcessor = getRemarkProcessor;
//# sourceMappingURL=helpers.js.map