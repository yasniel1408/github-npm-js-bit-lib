"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.VERSION_DELIMITER = void 0;
const decamelize_1 = __importDefault(require("decamelize"));
const path = __importStar(require("path"));
const semver = __importStar(require("semver"));
const lodash_1 = require("lodash");
const component_version_1 = require("@teambit/component-version");
const is_valid_id_chunk_1 = __importDefault(require("./utils/is-valid-id-chunk"));
const is_valid_scope_name_1 = __importDefault(require("./utils/is-valid-scope-name"));
const exceptions_1 = require("./exceptions");
exports.VERSION_DELIMITER = '@';
class BitId {
    constructor({ scope, box, name, version }) {
        // don't validate the id parts using isValidIdChunk here. we instance this class tons of times
        // and running regex so many times impact the performance
        if (!name)
            throw new exceptions_1.InvalidName(name);
        this.scope = scope || null;
        this.box = undefined;
        this.name = box ? `${box}/${name}` : name;
        this.version = version || undefined;
        Object.freeze(this);
    }
    clone() {
        return new BitId(this);
    }
    changeScope(newScope) {
        return new BitId({ scope: newScope, name: this.name, version: this.version });
    }
    changeVersion(newVersion) {
        return new BitId({ scope: this.scope, name: this.name, version: newVersion });
    }
    isLocal(scopeName) {
        return !this.scope || Boolean(scopeName && scopeName === this.scope);
    }
    getVersion() {
        return (0, component_version_1.versionParser)(this.version);
    }
    hasVersion() {
        return Boolean(this.version && this.version !== component_version_1.LATEST_VERSION);
    }
    hasScope() {
        return Boolean(this.scope);
    }
    hasSameName(id) {
        return this.name === id.name;
    }
    hasSameScope(id) {
        if (this.hasScope() && id.hasScope())
            return this.scope === id.scope;
        if (!this.hasScope() && !id.hasScope())
            return true;
        return false; // one has scope but not the other
    }
    hasSameVersion(id) {
        if (this.hasVersion() && id.hasVersion())
            return this.version === id.version;
        if (!this.hasVersion() && !id.hasVersion())
            return true;
        return false; // one has version but not the other
    }
    toString(ignoreScope = false, ignoreVersion = false) {
        const { name, version } = this;
        const scope = this.scope;
        const componentStr = ignoreScope || !scope ? name : [scope, name].join('/');
        // when there is no scope and the version is latest, omit the version.
        if (ignoreVersion || !this.hasVersion())
            return componentStr;
        // $FlowFixMe version here is a string because this.hasVersion() is true
        return componentStr.concat(`${exports.VERSION_DELIMITER}${version}`);
    }
    toStringWithoutScope() {
        return this.toString(true);
    }
    toStringWithoutVersion() {
        return this.toString(false, true);
    }
    toStringWithoutScopeAndVersion() {
        return this.toString(true, true);
    }
    isEqual(bitId) {
        return this.hasSameName(bitId) && this.hasSameScope(bitId) && this.hasSameVersion(bitId);
    }
    isEqualWithoutVersion(bitId) {
        return this.hasSameName(bitId) && this.hasSameScope(bitId);
    }
    isEqualWithoutScopeAndVersion(bitId) {
        return this.hasSameName(bitId);
    }
    serialize() {
        const obj = { scope: this.scope, name: this.name, version: this.version };
        if (!this.hasVersion())
            delete obj.version;
        if (!this.hasScope())
            delete obj.scope;
        return obj;
    }
    toFullPath() {
        if (!this.scope || !this.version) {
            throw new Error('BitId.toFullPath is unable to generate a path without a scope or a version');
        }
        return path.join(this.name, this.scope, this.version);
    }
    isVersionSnap() {
        return (0, component_version_1.isHash)(this.version);
    }
    /**
     * examples:
     * 1.0.0 => null
     * 1.0.0-dev.1 => ['dev', 1]
     * 1.0.0-dev.1.alpha.2 => ['dev', 1, 'alpha', 2]
     * 1.0.0-0 => [0]
     */
    getVersionPreReleaseData() {
        if (!this.version)
            return null;
        return semver.prerelease(this.version);
    }
    /**
     * Get a string id and return a string without the version part
     * @param {string} id
     * @return {string} id - id without version
     */
    static getStringWithoutVersion(id) {
        const splitted = id.split(exports.VERSION_DELIMITER);
        let res = splitted[0];
        // the delimiter is @. now with the new owner prefix
        // many times the id starts with the @ sign as part of the @owner prefix
        // do not treat this @ at the beginning as the version delimiter
        if (id.startsWith(exports.VERSION_DELIMITER)) {
            res = `${exports.VERSION_DELIMITER}${splitted[1]}`;
        }
        return res;
    }
    static getVersionOnlyFromString(id) {
        return id.split(exports.VERSION_DELIMITER)[1];
    }
    static parse(id, hasScope = true, version = component_version_1.LATEST_VERSION) {
        if (typeof id !== 'string') {
            throw new TypeError(`BitId.parse expects to get "id" as a string, instead, got ${typeof id}`);
        }
        if (id.includes(exports.VERSION_DELIMITER) && id.lastIndexOf(exports.VERSION_DELIMITER) > 0) {
            const [newId, newVersion] = id.split(exports.VERSION_DELIMITER);
            id = newId;
            version = newVersion;
        }
        const getScopeAndName = () => {
            if (hasScope) {
                return BitId.getScopeAndName(id);
            }
            return {
                scope: undefined,
                name: id,
            };
        };
        const { scope, name } = getScopeAndName();
        if (!(0, is_valid_id_chunk_1.default)(name))
            throw new exceptions_1.InvalidName(name);
        if (scope && !(0, is_valid_scope_name_1.default)(scope)) {
            throw new exceptions_1.InvalidScopeName(scope, id);
        }
        return new BitId({
            scope,
            name,
            version,
        });
    }
    static getScopeAndName(id) {
        const delimiterIndex = id.indexOf('/');
        if (delimiterIndex < 0)
            throw new exceptions_1.InvalidBitId(id);
        const scope = id.substring(0, delimiterIndex);
        const name = id.substring(delimiterIndex + 1);
        return {
            scope,
            name,
        };
    }
    static parseObsolete(id, version = component_version_1.LATEST_VERSION) {
        if (id.includes(exports.VERSION_DELIMITER)) {
            const [newId, newVersion] = id.split(exports.VERSION_DELIMITER);
            id = newId;
            version = newVersion;
        }
        const idSplit = id.split('/');
        if (idSplit.length === 3) {
            const [scope, box, name] = idSplit;
            if (!(0, is_valid_id_chunk_1.default)(name, false) || !(0, is_valid_id_chunk_1.default)(box, false) || !(0, is_valid_scope_name_1.default)(scope)) {
                throw new exceptions_1.InvalidIdChunk(`${scope}/${box}/${name}`);
            }
            // $FlowFixMe (in this case the realScopeName is not undefined)
            return new BitId({
                scope,
                box,
                name,
                version,
            });
        }
        if (idSplit.length === 2) {
            const [box, name] = idSplit;
            if (!(0, is_valid_id_chunk_1.default)(name, false) || !(0, is_valid_id_chunk_1.default)(box, false)) {
                throw new exceptions_1.InvalidIdChunk(`${box}/${name}`);
            }
            return new BitId({
                box,
                name,
                version,
            });
        }
        if (idSplit.length === 1) {
            const [name] = idSplit;
            if (!(0, is_valid_id_chunk_1.default)(name)) {
                throw new exceptions_1.InvalidIdChunk(name);
            }
            return new BitId({
                name,
                version,
            });
        }
        throw new exceptions_1.InvalidBitId(id);
    }
    /**
     * before version 13.0.3 bitmap and component-dependencies ids were written as strings (e.g. scope/box/name@version)
     * since that version the ids are written as objects ({ scope: scopeName, name: compName, version: 0.0.1 })
     */
    static parseBackwardCompatible(id) {
        return typeof id === 'string' ? BitId.parseObsolete(id) : new BitId(id);
    }
    static getValidScopeName(scope) {
        const suggestedName = scope.toLowerCase();
        let cleanName = suggestedName
            .split('')
            .map((char) => {
            if (/^[$\-_!.a-z0-9]+$/.test(char))
                return char;
            return '';
        })
            .join('');
        // allow only one dot
        const nameSplitByDot = cleanName.split('.');
        if (nameSplitByDot.length > 1) {
            cleanName = `${(0, lodash_1.head)(nameSplitByDot)}.${(0, lodash_1.tail)(nameSplitByDot).join('')}`;
        }
        if (!cleanName) {
            // @todo: change it to BitError
            throw new Error('scope name created by directory name have to contains at least one character or number');
        }
        return cleanName;
    }
    static getValidIdChunk(chunk) {
        if (!(0, is_valid_id_chunk_1.default)(chunk)) {
            chunk = chunk.replace(/\./g, ''); // remove "."
            chunk = chunk.replace(/ /g, '-'); // replace a space with a dash.
            chunk = (0, decamelize_1.default)(chunk, '-');
        }
        return chunk;
    }
    static getValidBitId(box, name) {
        return new BitId({ name: BitId.getValidIdChunk(name), box: box ? BitId.getValidIdChunk(box) : undefined });
    }
    static isValidVersion(version) {
        // a version can be a tag (semver) or a snap (hash)
        return BitId.isValidSemver(version) || (0, component_version_1.isHash)(version);
    }
    static isValidSemver(version) {
        return Boolean(semver.valid(version));
    }
}
exports.default = BitId;
//# sourceMappingURL=bit-id.js.map