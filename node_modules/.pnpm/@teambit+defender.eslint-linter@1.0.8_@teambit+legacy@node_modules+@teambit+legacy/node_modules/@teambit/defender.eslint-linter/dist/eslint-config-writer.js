"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EslintConfigWriter = void 0;
const comment_json_1 = require("comment-json");
const utils_1 = require("@teambit/legacy/dist/utils");
const fs_extra_1 = __importDefault(require("fs-extra"));
const typescript_typescript_compiler_1 = require("@teambit/typescript.typescript-compiler");
const lodash_1 = require("lodash");
const get_eslint_config_1 = require("./get-eslint-config");
const BIT_GENERATED_ESLINT_CONFIG_COMMENT = '// bit-generated-eslint-config';
class EslintConfigWriter {
    constructor(name, eslintConfig, logger, tsconfig) {
        this.name = name;
        this.eslintConfig = eslintConfig;
        this.logger = logger;
        this.tsconfig = tsconfig;
        this.id = 'eslint';
        this.patterns = ['**/.eslintrc.json'];
    }
    calcConfigFiles(_executionContext, envMapValue, configsRootDir) {
        const config = this.eslintConfig.overrideConfig;
        if (!config)
            return [];
        const eslintConfigFile = {
            content: JSON.stringify(config, null, 2),
            name: '.eslintrc.bit.{hash}.json',
        };
        if (!this.tsconfig || (0, lodash_1.isEmpty)(this.tsconfig)) {
            return [eslintConfigFile];
        }
        const tsConfigContent = JSON.stringify(this.tsconfig, null, 2);
        // It's important to calculate the hash before we call the expandIncludeExclude function
        // to make sure we get the same hash for the same config.
        // we will merge different include/exclude patterns to the same config file as part of the mergeConfigFiles
        // below
        const tsConfigHash = (0, utils_1.sha1)(tsConfigContent);
        const tsConfigName = `tsconfig.bit.eslint.${tsConfigHash}.json`;
        const tsConfigPath = `${configsRootDir}/${tsConfigName}`;
        const tsConfigCloned = JSON.parse(tsConfigContent);
        const compDirs = envMapValue.paths;
        const newTsConfig = (0, typescript_typescript_compiler_1.expandIncludeExclude)(tsConfigPath, tsConfigCloned, compDirs, typescript_typescript_compiler_1.GLOBAL_TYPES_DIR);
        const newTsConfigContent = JSON.stringify(newTsConfig, null, 2);
        const tsConfigFile = {
            content: newTsConfigContent,
            hash: tsConfigHash,
            name: tsConfigName,
        };
        // This must use abs path, as otherwise eslint will not find the tsconfig file
        // because it will search for it relative to the workspace root
        (0, lodash_1.set)(config, 'parserOptions.project', tsConfigPath);
        eslintConfigFile.content = JSON.stringify(config, null, 2);
        return [eslintConfigFile, tsConfigFile];
    }
    mergeConfigFiles(configFile, configFile2) {
        // Only merge tsconfig files (not eslint config files for example)
        if (!configFile.name.includes('tsconfig.bit')) {
            return configFile.content;
        }
        const tsConfig1 = (0, comment_json_1.parse)(configFile.content);
        const tsConfig2 = (0, comment_json_1.parse)(configFile2.content);
        // @ts-ignore
        tsConfig1.include = (0, lodash_1.uniq)([...((tsConfig1 === null || tsConfig1 === void 0 ? void 0 : tsConfig1.include) || []), ...((tsConfig2 === null || tsConfig2 === void 0 ? void 0 : tsConfig2.include) || [])]).sort();
        // @ts-ignore
        tsConfig1.exclude = (0, lodash_1.uniq)([...((tsConfig1 === null || tsConfig1 === void 0 ? void 0 : tsConfig1.exclude) || []), ...((tsConfig2 === null || tsConfig2 === void 0 ? void 0 : tsConfig2.exclude) || [])]).sort();
        const content = (0, comment_json_1.stringify)(tsConfig1, null, 2);
        return content;
    }
    generateExtendingFile(args) {
        const { writtenConfigFiles } = args;
        const eslintConfigFile = writtenConfigFiles.find((file) => file.name.includes('.eslintrc.bit'));
        if (!eslintConfigFile)
            return undefined;
        const config = {
            // Using DSL to make sure it will be replaced with relative path
            extends: [`{${eslintConfigFile.name}}`],
        };
        const content = `${BIT_GENERATED_ESLINT_CONFIG_COMMENT}\n${JSON.stringify(config, null, 2)}`;
        return { content, name: '.eslintrc.json', extendingTarget: eslintConfigFile, useAbsPaths: false };
    }
    isBitGenerated(filePath) {
        const content = fs_extra_1.default.readFileSync(filePath).toString();
        return content.includes(BIT_GENERATED_ESLINT_CONFIG_COMMENT);
    }
    static from(options) {
        const name = options.name || 'EslintConfigWriter';
        const handler = (context) => {
            return EslintConfigWriter.create(options, context.createLogger(name));
        };
        return {
            name,
            handler,
        };
    }
    static create(options, logger) {
        const name = options.name || 'EslintConfigWriter';
        const rawTsConfig = (0, typescript_typescript_compiler_1.computeTsConfig)({
            tsconfig: options.tsconfig,
            compilerOptions: options.compilerOptions,
        });
        const eslintConfig = (0, get_eslint_config_1.computeEslintConfig)(options);
        return new EslintConfigWriter(name, eslintConfig, logger, rawTsConfig);
    }
}
exports.EslintConfigWriter = EslintConfigWriter;
//# sourceMappingURL=eslint-config-writer.js.map