"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ESLintLinter = void 0;
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const lodash_1 = require("lodash");
const eslint_1 = require("eslint");
const p_map_series_1 = __importDefault(require("p-map-series"));
const object_hash_1 = __importDefault(require("object-hash"));
const typescript_typescript_compiler_1 = require("@teambit/typescript.typescript-compiler");
const get_eslint_config_1 = require("./get-eslint-config");
function getCacheDir(rootDir) {
    return path_1.default.join(rootDir, 'node_modules', '.cache');
}
class ESLintLinter {
    constructor(id = 'eslint-linter', logger, options, rawEslintConfig, rawTsConfig, 
    /**
     * reference to the eslint module.
     */
    ESLint) {
        this.id = id;
        this.logger = logger;
        this.options = options;
        this.rawEslintConfig = rawEslintConfig;
        this.rawTsConfig = rawTsConfig;
        this.ESLint = ESLint;
        // eslint-disable-next-line react/static-property-placement
        this.displayName = 'ESlint';
    }
    displayConfig() {
        return JSON.stringify(this.options, null, 2);
    }
    lint(context, buildContext) {
        return __awaiter(this, void 0, void 0, function* () {
            const longProcessLogger = this.logger.createLongProcessLogger('linting components', context.components.length);
            let tsConfigPath;
            if (this.rawTsConfig && context.rootDir) {
                tsConfigPath = this.createTempTsConfigFile(context.rootDir, context.componentsDirMap, context.envRuntime.id, this.rawTsConfig);
            }
            const runtimeConfig = (0, get_eslint_config_1.computeRuntimeEslintConfig)(this.rawEslintConfig, context, tsConfigPath);
            const eslint = this.createEslint(runtimeConfig, this.ESLint);
            const resultsP = (0, p_map_series_1.default)(context.components, (component) => __awaiter(this, void 0, void 0, function* () {
                longProcessLogger.logProgress(`component: ${component.id.toString()}, # of files: ${component.filesystem.files.length}`);
                const files = this.getFilesPaths(component, buildContext);
                const lintResults = yield eslint.lintFiles(files);
                if (eslint && runtimeConfig.fix && lintResults) {
                    yield eslint_1.ESLint.outputFixes(lintResults);
                }
                const results = (0, lodash_1.compact)((0, lodash_1.flatten)(lintResults));
                const formatter = yield eslint.loadFormatter(this.options.formatter || 'stylish');
                const output = formatter.format(results);
                const { totalErrorCount, totalFatalErrorCount, totalFixableErrorCount, totalFixableWarningCount, totalWarningCount, componentsResults, } = this.computeComponentResultsWithTotals(results);
                return {
                    component,
                    output,
                    totalErrorCount,
                    totalFatalErrorCount,
                    totalFixableErrorCount,
                    totalFixableWarningCount,
                    totalWarningCount,
                    results: componentsResults,
                };
            }));
            const results = (yield resultsP);
            const { totalErrorCount, totalFatalErrorCount, totalFixableErrorCount, totalFixableWarningCount, totalWarningCount, totalComponentsWithErrorCount, totalComponentsWithFatalErrorCount, totalComponentsWithFixableErrorCount, totalComponentsWithFixableWarningCount, totalComponentsWithWarningCount, } = this.computeManyComponentsTotals(results);
            return {
                totalErrorCount,
                totalFatalErrorCount,
                totalFixableErrorCount,
                totalFixableWarningCount,
                totalWarningCount,
                totalComponentsWithErrorCount,
                totalComponentsWithFatalErrorCount,
                totalComponentsWithFixableErrorCount,
                totalComponentsWithFixableWarningCount,
                totalComponentsWithWarningCount,
                results,
                errors: [],
            };
        });
    }
    getFilesPaths(component, buildContext) {
        let capsule;
        if (buildContext) {
            capsule = buildContext.capsuleNetwork.graphCapsules.getCapsule(component.id);
        }
        const files = component.filesystem.files.map((file) => {
            var _a;
            // TODO: now that we moved to lint files, maybe it's not required anymore
            // The eslint api will not ignore extensions by default when using lintText, so we do it manually
            if (!((_a = this.options.extensions) === null || _a === void 0 ? void 0 : _a.includes(file.extname)))
                return undefined;
            if (!capsule)
                return file.path;
            return path_1.default.join(capsule.path, file.relative);
        });
        // const files = await Promise.all(filesP);
        return (0, lodash_1.compact)(files);
    }
    createTempTsConfigFile(rootDir, componentDirMap, envId, tsConfig) {
        const newTsConfig = Object.assign({}, tsConfig);
        const compDirs = componentDirMap.toArray().map(([, compDir]) => compDir);
        if (tsConfig.include) {
            newTsConfig.include = (0, lodash_1.flatten)(tsConfig.include.map((includedPath) => {
                return compDirs.map((compDir) => `../../${compDir}/${includedPath}`);
            }));
        }
        if (tsConfig.exclude) {
            newTsConfig.exclude = (0, lodash_1.flatten)(tsConfig.exclude.map((excludedPath) => {
                return compDirs.map((compDir) => `../../${compDir}/${excludedPath}`);
            }));
        }
        const cacheDir = getCacheDir(rootDir);
        const hash = (0, object_hash_1.default)(newTsConfig);
        // We save the tsconfig with hash here to avoid creating unnecessary tsconfig files
        // this is very important as eslint will be able to cache the tsconfig file and will not need to create another program
        // this affects performance dramatically
        const tempTsConfigPath = path_1.default.join(cacheDir, `bit.tsconfig.eslint.${hash}.json`);
        if (!fs_extra_1.default.existsSync(tempTsConfigPath)) {
            fs_extra_1.default.outputJSONSync(tempTsConfigPath, newTsConfig, { spaces: 2 });
        }
        return tempTsConfigPath;
    }
    computeComponentResultsWithTotals(results) {
        let totalErrorCount = 0;
        let totalFatalErrorCount = 0;
        let totalFixableErrorCount = 0;
        let totalFixableWarningCount = 0;
        let totalWarningCount = 0;
        const componentsResults = results.map((result) => {
            var _a, _b, _c, _d, _e;
            totalErrorCount += (_a = result.errorCount) !== null && _a !== void 0 ? _a : 0;
            // @ts-ignore - missing from the @types/eslint lib
            totalFatalErrorCount += (_b = result.fatalErrorCount) !== null && _b !== void 0 ? _b : 0;
            totalFixableErrorCount += (_c = result.fixableErrorCount) !== null && _c !== void 0 ? _c : 0;
            totalFixableWarningCount += (_d = result.fixableWarningCount) !== null && _d !== void 0 ? _d : 0;
            totalWarningCount += (_e = result.warningCount) !== null && _e !== void 0 ? _e : 0;
            return {
                filePath: result.filePath,
                errorCount: result.errorCount,
                // @ts-ignore - missing from the @types/eslint lib
                fatalErrorCount: result.fatalErrorCount,
                fixableErrorCount: result.fixableErrorCount,
                fixableWarningCount: result.fixableWarningCount,
                warningCount: result.warningCount,
                messages: result.messages,
                raw: result,
            };
        });
        return {
            totalErrorCount,
            totalFatalErrorCount,
            totalFixableErrorCount,
            totalFixableWarningCount,
            totalWarningCount,
            componentsResults,
        };
    }
    computeManyComponentsTotals(componentsResults) {
        let totalErrorCount = 0;
        let totalFatalErrorCount = 0;
        let totalFixableErrorCount = 0;
        let totalFixableWarningCount = 0;
        let totalWarningCount = 0;
        let totalComponentsWithErrorCount = 0;
        let totalComponentsWithFatalErrorCount = 0;
        let totalComponentsWithFixableErrorCount = 0;
        let totalComponentsWithFixableWarningCount = 0;
        let totalComponentsWithWarningCount = 0;
        componentsResults.forEach((result) => {
            if (result.totalErrorCount) {
                totalErrorCount += result.totalErrorCount;
                totalComponentsWithErrorCount += 1;
            }
            // @ts-ignore - missing from the @types/eslint lib
            if (result.totalFatalErrorCount) {
                totalFatalErrorCount += result.totalFatalErrorCount;
                totalComponentsWithFatalErrorCount += 1;
            }
            if (result.totalFixableErrorCount) {
                totalFixableErrorCount += result.totalFixableErrorCount;
                totalComponentsWithFixableErrorCount += 1;
            }
            if (result.totalFixableWarningCount) {
                totalFixableWarningCount += result.totalFixableWarningCount;
                totalComponentsWithFixableWarningCount += 1;
            }
            if (result.totalWarningCount) {
                totalWarningCount += result.totalWarningCount;
                totalComponentsWithWarningCount += 1;
            }
        });
        return {
            totalErrorCount,
            totalFatalErrorCount,
            totalFixableErrorCount,
            totalFixableWarningCount,
            totalWarningCount,
            componentsResults,
            totalComponentsWithErrorCount,
            totalComponentsWithFatalErrorCount,
            totalComponentsWithFixableErrorCount,
            totalComponentsWithFixableWarningCount,
            totalComponentsWithWarningCount,
        };
    }
    /**
     * Create the eslint instance by options that was already merged with context
     * @param options
     * @param ESLintModule
     * @returns
     */
    createEslint(options, ESLintModule) {
        if (ESLintModule)
            return new ESLintModule(options);
        const eslintInstance = new eslint_1.ESLint(options);
        return eslintInstance;
    }
    version() {
        if (this.ESLint)
            return this.ESLint.version;
        return eslint_1.ESLint.version;
    }
    static from(options) {
        return (context) => {
            const name = options.name || 'eslint-linter';
            const logger = context.createLogger(name);
            const rawTsConfig = (0, typescript_typescript_compiler_1.computeTsConfig)({
                tsconfig: options.tsconfig,
                compilerOptions: options.compilerOptions,
            });
            const eslintConfig = (0, get_eslint_config_1.computeEslintConfig)(options);
            return new ESLintLinter(name, logger, options, eslintConfig, rawTsConfig, options.eslint || eslint_1.ESLint);
        };
    }
}
exports.ESLintLinter = ESLintLinter;
//# sourceMappingURL=eslint-linter.js.map