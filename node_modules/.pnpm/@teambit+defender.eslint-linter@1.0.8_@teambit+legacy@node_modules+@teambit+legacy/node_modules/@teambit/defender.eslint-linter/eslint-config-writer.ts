import { ESLint as ESLintLib } from 'eslint';
import { stringify, parse } from 'comment-json';
import { sha1 } from '@teambit/legacy/dist/utils';
import fs from 'fs-extra';
import { EnvContext, ExecutionContext } from '@teambit/envs';
import type {
  ConfigWriterEntry,
  EnvMapValue, ExtendingConfigFile,
  ConfigFile,
  GenerateExtendingConfigFilesArgs,
  ConfigWriterHandler
} from '@teambit/workspace-config-files';
import { GLOBAL_TYPES_DIR, computeTsConfig, expandIncludeExclude } from '@teambit/typescript.typescript-compiler';
import { set, isEmpty, uniq } from 'lodash';
import { Logger } from '@teambit/logger';
import { ESLintOptions } from './eslint-linter-options';
import { computeEslintConfig } from './get-eslint-config';

const BIT_GENERATED_ESLINT_CONFIG_COMMENT = '// bit-generated-eslint-config';

export type EslintConfigWriterOptions = Pick<
  ESLintOptions,
  'name' | 'configPath' | 'config' | 'tsconfig' | 'compilerOptions'
>;

export class EslintConfigWriter implements ConfigWriterEntry {
  id = 'eslint';
  patterns: string[] = ['**/.eslintrc.json'];

  constructor(
    readonly name: string,
    private eslintConfig: ESLintLib.Options,
    private logger: Logger,
    private tsconfig?: Record<string, any>,
  ) {}

  calcConfigFiles(
    _executionContext: ExecutionContext,
    envMapValue: EnvMapValue,
    configsRootDir: string
  ): ConfigFile[] | undefined {
    const config = this.eslintConfig.overrideConfig;
    if (!config) return [];
    const eslintConfigFile = {
      content: JSON.stringify(config, null, 2),
      name: '.eslintrc.bit.{hash}.json',
    };
    if (!this.tsconfig || isEmpty(this.tsconfig)) {
      return [eslintConfigFile];
    }

    const tsConfigContent = JSON.stringify(this.tsconfig, null, 2);
    // It's important to calculate the hash before we call the expandIncludeExclude function
    // to make sure we get the same hash for the same config.
    // we will merge different include/exclude patterns to the same config file as part of the mergeConfigFiles
    // below
    const tsConfigHash = sha1(tsConfigContent);
    const tsConfigName = `tsconfig.bit.eslint.${tsConfigHash}.json`;
    const tsConfigPath = `${configsRootDir}/${tsConfigName}`;
    const tsConfigCloned = JSON.parse(tsConfigContent);
    const compDirs: string[] = envMapValue.paths;
    const newTsConfig = expandIncludeExclude(tsConfigPath, tsConfigCloned, compDirs, GLOBAL_TYPES_DIR);
    const newTsConfigContent = JSON.stringify(newTsConfig, null, 2);

    const tsConfigFile = {
      content: newTsConfigContent,
      hash: tsConfigHash,
      name: tsConfigName,
    };
    // This must use abs path, as otherwise eslint will not find the tsconfig file
    // because it will search for it relative to the workspace root
    set(config, 'parserOptions.project', tsConfigPath);
    eslintConfigFile.content = JSON.stringify(config, null, 2);
    return [eslintConfigFile, tsConfigFile];
  }

  mergeConfigFiles?(configFile: ConfigFile, configFile2: ConfigFile): string {
    // Only merge tsconfig files (not eslint config files for example)
    if (!configFile.name.includes('tsconfig.bit')) {
      return configFile.content;
    }
    const tsConfig1 = parse(configFile.content);
    const tsConfig2 = parse(configFile2.content);
    // @ts-ignore
    tsConfig1.include = uniq([...(tsConfig1?.include || []), ...(tsConfig2?.include || [])]).sort();
    // @ts-ignore
    tsConfig1.exclude = uniq([...(tsConfig1?.exclude || []), ...(tsConfig2?.exclude || [])]).sort();
    const content = stringify(tsConfig1, null, 2);
    return content;
  }

  generateExtendingFile(args: GenerateExtendingConfigFilesArgs): ExtendingConfigFile | undefined {
    const { writtenConfigFiles } = args;
    const eslintConfigFile = writtenConfigFiles.find((file) => file.name.includes('.eslintrc.bit'));
    if (!eslintConfigFile) return undefined;
    const config = {
      // Using DSL to make sure it will be replaced with relative path
      extends: [`{${eslintConfigFile.name}}`],
    };
    const content = `${BIT_GENERATED_ESLINT_CONFIG_COMMENT}\n${JSON.stringify(config, null, 2)}`;
    return { content, name: '.eslintrc.json', extendingTarget: eslintConfigFile, useAbsPaths: false };
  }

  isBitGenerated(filePath: string): boolean {
    const content = fs.readFileSync(filePath).toString();
    return content.includes(BIT_GENERATED_ESLINT_CONFIG_COMMENT);
  }

  static from(options: EslintConfigWriterOptions): ConfigWriterHandler {
    const name = options.name || 'EslintConfigWriter';
    const handler = (context: EnvContext) => {
      return EslintConfigWriter.create(options, context.createLogger(name));
    };
    return {
      name,
      handler,
    };
  }

  static create(options: EslintConfigWriterOptions, logger: Logger): EslintConfigWriter {
    const name = options.name || 'EslintConfigWriter';

    const rawTsConfig = computeTsConfig({
      tsconfig: options.tsconfig,
      compilerOptions: options.compilerOptions,
    });

    const eslintConfig = computeEslintConfig(options);
    return new EslintConfigWriter(name, eslintConfig, logger, rawTsConfig);
  }
}
