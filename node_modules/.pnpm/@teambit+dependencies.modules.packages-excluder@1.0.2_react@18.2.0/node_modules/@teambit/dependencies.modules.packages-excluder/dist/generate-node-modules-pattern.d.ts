export declare enum PatternTarget {
    /**
     * Used in Jest `transformIgnorePatterns` options
     */
    JEST = "jest",
    /**
     * Used in Webpack `snapshot.managedPaths` options
     */
    WEBPACK = "webpack"
}
declare type GenerateNodeModulesPatternOptions<T> = {
    /**
     * An array of packages name to exclude in the regex.
     */
    packages?: string[];
    /**
     * The regex should exclude component packages.
     * A component package looks like `@org/scope.namespace.component-name`.
     */
    excludeComponents?: boolean;
    /**
     * The target for which patterns are generated.
     */
    target?: T;
};
declare const patternTargetMap: {
    jest: typeof toJestPattern;
    webpack: typeof toWebpackPattern;
};
declare type PatternTargetMap = typeof patternTargetMap;
declare type PatternReturnType<T extends PatternTarget> = ReturnType<PatternTargetMap[T]>;
/**
 * A function that receives an array of packages names and returns a pattern (string) of a regex that matches any node_modules/package-name except the provided package-names.
 * @param {string[]} packages - array of packages.
 * @returns {string} node modules catched packages regex.
 */
export declare function generateNodeModulesPattern<T extends PatternTarget>(options?: GenerateNodeModulesPatternOptions<T>): PatternReturnType<T>;
declare function toJestPattern(patterns: string[]): string;
/**
 * Webpack managed paths evaluate absolutes paths to `package.json` files.
 * We need to generate a pattern that excludes the `package.json` files of the bit component packages.
 * Example:
 * - Component package: `@my-org/my-scope.components`
 * - Webpack path: `/Users/aUser/dev/bit-example/node_modules/@my-org/my-scope.components/package.json`
 * - RegExp to exclude this path from managed paths: `/^(.+?[\\/]node_modules[\\/](?!(@my-org[\\/]my-scope.components))(@.+?[\\/])?.+?)[\\/]/`
 */
declare function toWebpackPattern(patterns: string[]): string[];
export {};
