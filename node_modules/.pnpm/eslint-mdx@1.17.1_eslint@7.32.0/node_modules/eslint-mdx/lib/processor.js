"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRemarkProcessor = exports.processorCache = exports.remarkProcessor = exports.getPhysicalFilename = exports.requirePkg = void 0;
const tslib_1 = require("tslib");
const fs_1 = (0, tslib_1.__importDefault)(require("fs"));
const path_1 = (0, tslib_1.__importDefault)(require("path"));
const cosmiconfig_1 = require("cosmiconfig");
const remark_mdx_1 = (0, tslib_1.__importDefault)(require("remark-mdx"));
const remark_parse_1 = (0, tslib_1.__importDefault)(require("remark-parse"));
const remark_stringify_1 = (0, tslib_1.__importDefault)(require("remark-stringify"));
const unified_1 = (0, tslib_1.__importDefault)(require("unified"));
const helpers_1 = require("./helpers");
const requirePkg = (plugin, prefix, filePath) => {
    if (filePath && /^\.\.?([/\\]|$)/.test(plugin)) {
        plugin = path_1.default.resolve(path_1.default.dirname(filePath), plugin);
    }
    prefix = prefix.endsWith('-') ? prefix : prefix + '-';
    const packages = [
        plugin,
        plugin.startsWith('@')
            ? plugin.replace('/', '/' + prefix)
            : prefix + plugin,
    ];
    let error;
    for (const pkg of packages) {
        try {
            // eslint-disable-next-line @typescript-eslint/no-require-imports, @typescript-eslint/no-var-requires
            return require(pkg);
        }
        catch (err) {
            if (!error) {
                error = err;
            }
        }
    }
    throw error;
};
exports.requirePkg = requirePkg;
/**
 * Given a filepath, get the nearest path that is a regular file.
 * The filepath provided by eslint may be a virtual filepath rather than a file
 * on disk. This attempts to transform a virtual path into an on-disk path
 */
const getPhysicalFilename = (filename) => {
    try {
        if (fs_1.default.statSync(filename).isFile()) {
            return filename;
        }
    }
    catch (err) {
        // https://github.com/eslint/eslint/issues/11989
        if (err.code === 'ENOTDIR') {
            return (0, exports.getPhysicalFilename)(path_1.default.dirname(filename));
        }
    }
    return filename;
};
exports.getPhysicalFilename = getPhysicalFilename;
exports.remarkProcessor = (0, unified_1.default)().use(remark_parse_1.default).freeze();
const explorer = (0, cosmiconfig_1.cosmiconfigSync)('remark', {
    packageProp: 'remarkConfig',
});
// @internal - exported for testing
exports.processorCache = new Map();
const getRemarkProcessor = (searchFrom, isMdx, ignoreRemarkConfig) => {
    const initCacheKey = `${String(isMdx)}-${searchFrom}`;
    let cachedProcessor = exports.processorCache.get(initCacheKey);
    if (cachedProcessor) {
        return cachedProcessor;
    }
    const result = ignoreRemarkConfig
        ? null
        : explorer.search(searchFrom);
    const cacheKey = result ? `${String(isMdx)}-${result.filepath}` : '';
    cachedProcessor = exports.processorCache.get(cacheKey);
    if (cachedProcessor) {
        return cachedProcessor;
    }
    if (result) {
        /* istanbul ignore next */
        const { plugins = [], settings } = (result.config ||
            {});
        // disable this rule automatically since we already have a parser option `extensions`
        // only disable this plugin if there are at least one plugin enabled
        // otherwise it is redundant
        /* istanbul ignore else */
        if (plugins.length > 0) {
            try {
                plugins.push([require.resolve('remark-lint-file-extension'), false]);
            }
            catch (_a) {
                // just ignore if the package does not exist
            }
        }
        const initProcessor = (0, exports.remarkProcessor)()
            .use({ settings })
            .use(remark_stringify_1.default);
        if (isMdx) {
            initProcessor.use(remark_mdx_1.default);
        }
        cachedProcessor = plugins
            .reduce((processor, pluginWithSettings) => {
            const [plugin, ...pluginSettings] = (0, helpers_1.arrayify)(pluginWithSettings);
            return processor.use(
            /* istanbul ignore next */
            typeof plugin === 'string'
                ? (0, exports.requirePkg)(plugin, 'remark', result.filepath)
                : plugin, ...pluginSettings);
        }, initProcessor)
            .freeze();
    }
    else {
        const initProcessor = (0, exports.remarkProcessor)().use(remark_stringify_1.default);
        if (isMdx) {
            initProcessor.use(remark_mdx_1.default);
        }
        cachedProcessor = initProcessor.freeze();
    }
    exports.processorCache
        .set(initCacheKey, cachedProcessor)
        .set(cacheKey, cachedProcessor);
    return cachedProcessor;
};
exports.getRemarkProcessor = getRemarkProcessor;
//# sourceMappingURL=processor.js.map