"use strict";
/// <reference path="../typings.d.ts" />
Object.defineProperty(exports, "__esModule", { value: true });
exports.last = exports.first = exports.arrayify = exports.restoreNodeLocation = exports.getPositionAt = exports.hasProperties = exports.normalizePosition = exports.normalizeParser = exports.isJsxNode = exports.JSX_TYPES = exports.FALLBACK_PARSERS = void 0;
exports.FALLBACK_PARSERS = [
    '@typescript-eslint/parser',
    '@babel/eslint-parser',
    'babel-eslint',
    'espree',
];
exports.JSX_TYPES = ['JSXElement', 'JSXFragment'];
const isJsxNode = (node) => exports.JSX_TYPES.includes(node.type);
exports.isJsxNode = isJsxNode;
// eslint-disable-next-line sonarjs/cognitive-complexity
const normalizeParser = (parser) => {
    if (parser) {
        if (typeof parser === 'string') {
            // eslint-disable-next-line @typescript-eslint/no-require-imports, @typescript-eslint/no-var-requires
            parser = require(parser);
        }
        if (typeof parser === 'object') {
            parser =
                ('parseForESLint' in parser && parser.parseForESLint) ||
                    ('parse' in parser && parser.parse);
        }
        if (typeof parser !== 'function') {
            throw new TypeError(`Invalid custom parser for \`eslint-mdx\`: ${parser}`);
        }
        return [parser];
    }
    const parsers = [];
    // try to load FALLBACK_PARSERS automatically
    for (const fallback of exports.FALLBACK_PARSERS) {
        try {
            // eslint-disable-next-line @typescript-eslint/no-require-imports, @typescript-eslint/no-var-requires
            const fallbackParser = require(fallback);
            /* istanbul ignore next */
            const parserFn = 'parseForESLint' in fallbackParser
                ? // eslint-disable-next-line @typescript-eslint/unbound-method
                    fallbackParser.parseForESLint
                : // eslint-disable-next-line @typescript-eslint/unbound-method
                    fallbackParser.parse;
            /* istanbul ignore else */
            if (parserFn) {
                parsers.push(parserFn);
            }
        }
        catch (_a) { }
    }
    return parsers;
};
exports.normalizeParser = normalizeParser;
const normalizePosition = (loc) => {
    const start = loc.start.offset;
    const end = loc.end.offset;
    return {
        range: [start, end],
        loc,
        start,
        end,
    };
};
exports.normalizePosition = normalizePosition;
const hasProperties = (obj, properties) => typeof obj === 'object' &&
    obj &&
    properties.every(property => property in obj);
exports.hasProperties = hasProperties;
// fix #292
const getPositionAt = (code, offset) => {
    let currOffset = 0;
    const lines = code.split('\n');
    // eslint-disable-next-line unicorn/no-for-loop
    for (let index = 0; index < lines.length; index++) {
        const line = index + 1;
        const nextOffset = currOffset + lines[index].length;
        if (nextOffset >= offset) {
            return {
                line,
                column: offset - currOffset,
            };
        }
        currOffset = nextOffset + 1; // add a line break `\n` offset
    }
};
exports.getPositionAt = getPositionAt;
const restoreNodeLocation = (node, point) => {
    if (node && typeof node === 'object') {
        for (const value of Object.values(node)) {
            (0, exports.restoreNodeLocation)(value, point);
        }
    }
    if (!(0, exports.hasProperties)(node, ['loc', 'range'])) {
        return node;
    }
    let { loc: { start: startLoc, end: endLoc }, range: [start, end], } = node;
    const range = [(start += point.offset), (end += point.offset)];
    return Object.assign(node, {
        start,
        end,
        range,
        loc: {
            start: {
                line: point.line + startLoc.line,
                column: startLoc.column + (startLoc.line === 1 ? point.column : 0),
            },
            end: {
                line: point.line + endLoc.line,
                column: endLoc.column + (endLoc.line === 1 ? point.column : 0),
            },
        },
    });
};
exports.restoreNodeLocation = restoreNodeLocation;
const arrayify = (...args) => args.reduce((arr, curr) => {
    arr.push(...(Array.isArray(curr) ? curr : curr == null ? [] : [curr]));
    return arr;
}, []);
exports.arrayify = arrayify;
// eslint-disable-next-line @typescript-eslint/prefer-optional-chain -- test coverage
const first = (items) => items && items[0];
exports.first = first;
const last = (items) => items && items[items.length - 1];
exports.last = last;
//# sourceMappingURL=helpers.js.map