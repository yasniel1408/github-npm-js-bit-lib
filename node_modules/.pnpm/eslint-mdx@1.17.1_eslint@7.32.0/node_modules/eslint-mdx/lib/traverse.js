"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.traverse = exports.Traverse = void 0;
const helpers_1 = require("./helpers");
const parser_1 = require("./parser");
const regexp_1 = require("./regexp");
class Traverse {
    constructor({ code, enter }) {
        this.code = code;
        this._enter = enter;
    }
    combineLeftJsxNodes(jsxNodes, parent) {
        var _a;
        const start = jsxNodes[0].position.start;
        const end = Object.assign({}, (0, helpers_1.last)(jsxNodes).position.end);
        // fix #279
        if (parent && ((_a = parent.position.indent) === null || _a === void 0 ? void 0 : _a.length) > 0) {
            end.offset += parent.position.indent.reduce((acc, indent, index) => acc + (index ? /* istanbul ignore next */ indent + 1 : 0), 0);
        }
        return {
            type: 'jsx',
            data: jsxNodes[0].data,
            value: this.code.slice(start.offset, end.offset),
            position: {
                start,
                end,
            },
        };
    }
    // fix #7
    combineJsxNodes(nodes, parent) {
        let offset = 0;
        let hasOpenTag = false;
        const jsxNodes = [];
        const { length } = nodes;
        // eslint-disable-next-line sonarjs/cognitive-complexity
        return nodes.reduce((acc, node, index) => {
            if (node.type === 'jsx') {
                const value = node.value;
                if ((0, regexp_1.isOpenTag)(value)) {
                    offset++;
                    hasOpenTag = true;
                    jsxNodes.push(node);
                }
                else {
                    if ((0, regexp_1.isCloseTag)(value)) {
                        offset--;
                        jsxNodes.push(node);
                    }
                    else if ((0, regexp_1.isComment)(value) ||
                        (0, regexp_1.isSelfClosingTag)(value) ||
                        (0, regexp_1.isOpenCloseTag)(value)) {
                        jsxNodes.push(node);
                    }
                    else {
                        try {
                            // fix #138
                            jsxNodes.push(...(0, helpers_1.arrayify)(parser_1.parser.normalizeJsxNode(node, parent)));
                        }
                        catch (_a) {
                            // #272, we consider the first jsx node as open tag although it's not precise
                            // and #334, if there is no error thrown, do not fallback
                            if (!index) {
                                offset++;
                                hasOpenTag = true;
                            }
                            // #272 related
                            /* istanbul ignore else */
                            if (offset) {
                                jsxNodes.push(node);
                            }
                            else {
                                // should never happen, just for robustness
                                const { start } = node.position;
                                throw Object.assign(new SyntaxError('unknown jsx node: ' + JSON.stringify(value)), {
                                    lineNumber: start.line,
                                    column: start.column,
                                    index: start.offset,
                                });
                            }
                        }
                    }
                    if (!offset) {
                        // fix #158
                        const firstOpenTagIndex = jsxNodes.findIndex(node => typeof node.value === 'string' && (0, regexp_1.isOpenTag)(node.value));
                        if (firstOpenTagIndex === -1) {
                            if (hasOpenTag) {
                                acc.push(this.combineLeftJsxNodes(jsxNodes, parent));
                            }
                            else {
                                acc.push(...jsxNodes);
                            }
                        }
                        else {
                            acc.push(...jsxNodes.slice(0, firstOpenTagIndex), this.combineLeftJsxNodes(jsxNodes.slice(firstOpenTagIndex), parent));
                        }
                        jsxNodes.length = 0;
                    }
                }
            }
            else if (offset) {
                jsxNodes.push(node);
            }
            else {
                acc.push(node);
            }
            if (index === length - 1 && jsxNodes.length > 0) {
                acc.push(this.combineLeftJsxNodes(jsxNodes, parent));
            }
            return acc;
        }, []);
    }
    traverse(node, parent) {
        /* istanbul ignore if */
        if (!node) {
            // should never happen, just for robustness
            return;
        }
        if ('children' in node) {
            const parent = node;
            parent.children = this.combineJsxNodes(parent.children, parent);
            for (const child of parent.children) {
                this.traverse(child, parent);
            }
        }
        this._enter(node, parent);
    }
}
exports.Traverse = Traverse;
const traverse = (root, options) => new Traverse(options).traverse(root);
exports.traverse = traverse;
//# sourceMappingURL=traverse.js.map