"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseForESLint = exports.parse = exports.parser = exports.Parser = exports.DEFAULT_PARSER_OPTIONS = exports.PLACEHOLDER_FILE_PATH = exports.MARKDOWN_EXTENSIONS = exports.DEFAULT_EXTENSIONS = exports.LOC_ERROR_PROPERTIES = exports.ES_NODE_TYPES = exports.AST_PROPS = void 0;
const tslib_1 = require("tslib");
const path_1 = (0, tslib_1.__importDefault)(require("path"));
const helpers_1 = require("./helpers");
const processor_1 = require("./processor");
const regexp_1 = require("./regexp");
const traverse_1 = require("./traverse");
exports.AST_PROPS = ['body', 'comments', 'tokens'];
exports.ES_NODE_TYPES = ['export', 'import', 'jsx'];
exports.LOC_ERROR_PROPERTIES = ['column', 'lineNumber'];
exports.DEFAULT_EXTENSIONS = ['.mdx'];
exports.MARKDOWN_EXTENSIONS = ['.md'];
exports.PLACEHOLDER_FILE_PATH = '__placeholder__.mdx';
exports.DEFAULT_PARSER_OPTIONS = {
    comment: true,
    ecmaFeatures: {
        jsx: true,
    },
    ecmaVersion: 2015,
    sourceType: 'module',
    tokens: true,
    filePath: exports.PLACEHOLDER_FILE_PATH,
    // required for @typescript-eslint/parser
    // reference: https://github.com/typescript-eslint/typescript-eslint/pull/2028
    loc: true,
    range: true,
};
const JSX_WRAPPER_START = '<$>';
const JSX_WRAPPER_END = '</$>';
const OFFSET = JSX_WRAPPER_START.length;
class Parser {
    constructor() {
        // @internal
        this._options = exports.DEFAULT_PARSER_OPTIONS;
        this.parse = this.parse.bind(this);
        this.parseForESLint = this.parseForESLint.bind(this);
    }
    normalizeJsxNode(node, parent, options = this._options) {
        const value = node.value;
        if (node.type !== 'jsx' || (0, regexp_1.isComment)(value)) {
            return node;
        }
        const commentContent = regexp_1.COMMENT_CONTENT_REGEX.exec(value);
        if (commentContent) {
            const comments = [];
            const { position: { start: { line, column, offset: startOffset }, }, data, } = node;
            Object.assign(node, {
                data: Object.assign(Object.assign({}, data), { jsxType: 'JSXElementWithHTMLComments', comments, 
                    // jsx in paragraph is considered as plain html in mdx, what means html style comments are valid
                    // TODO: in this case, jsx style comments could be a mistake
                    inline: !!parent && parent.type !== 'root' }),
                value: value.replace(regexp_1.COMMENT_CONTENT_REGEX_GLOBAL, (matched, $0, $1, $2, offset) => {
                    const endOffset = offset + matched.length;
                    const startLines = value.slice(0, offset).split('\n');
                    const endLines = value.slice(0, endOffset).split('\n');
                    const fixed = `{/${'*'.repeat($0.length - 2)}${$1}${'*'.repeat($2.length - 2)}/}`;
                    const startLineOffset = startLines.length - 1;
                    const endLineOffset = endLines.length - 1;
                    comments.push({
                        fixed,
                        // ! eslint ast column is 0-indexed, but unified is 1-indexed
                        loc: {
                            start: {
                                line: line + startLineOffset,
                                column: (0, helpers_1.last)(startLines).length +
                                    (startLineOffset ? 0 : column - 1),
                                offset: startOffset + offset,
                            },
                            end: {
                                line: line + endLineOffset,
                                column: (0, helpers_1.last)(endLines).length + (endLineOffset ? 0 : column - 1),
                                offset: startOffset + endOffset,
                            },
                        },
                        origin: matched,
                    });
                    return fixed;
                }),
            });
        }
        return this._normalizeJsxNodes(node, options);
    }
    parse(code, options) {
        return this.parseForESLint(code, options).ast;
    }
    parseForESLint(code, options) {
        const extname = path_1.default.extname(options.filePath);
        const isMdx = [
            ...exports.DEFAULT_EXTENSIONS,
            ...(options.extensions || []),
        ].includes(extname);
        const isMarkdown = [
            ...exports.MARKDOWN_EXTENSIONS,
            ...(options.markdownExtensions || []),
        ].includes(extname);
        if (!isMdx && !isMarkdown) {
            return this._eslintParse(code, options);
        }
        const root = (0, processor_1.getRemarkProcessor)((0, processor_1.getPhysicalFilename)(options.filePath), isMdx, Boolean(options.ignoreRemarkConfig)).parse(code);
        this._ast = Object.assign(Object.assign({}, (0, helpers_1.normalizePosition)(root.position)), { type: 'Program', sourceType: options.sourceType || 'module', body: [], comments: [], tokens: [] });
        this._services = {
            JSXElementsWithHTMLComments: [],
        };
        if (isMdx) {
            (0, traverse_1.traverse)(root, {
                code,
                enter: (node, parent) => {
                    if (!exports.ES_NODE_TYPES.includes(node.type)) {
                        return;
                    }
                    for (const normalizedNode of (0, helpers_1.arrayify)(this.normalizeJsxNode(node, parent, options))) {
                        this._nodeToAst(code, normalizedNode, options);
                    }
                },
            });
        }
        return {
            ast: this._ast,
            services: this._services,
        };
    }
    // @internal
    _eslintParse(code, options) {
        if (!this._parsers || options.parser !== this._options.parser) {
            this._parsers = (0, helpers_1.normalizeParser)(options.parser);
        }
        /* istanbul ignore else */
        if (options.filePath && this._options !== options) {
            Object.assign(this._options, options);
        }
        let program;
        let parseError;
        for (const parser of this._parsers) {
            try {
                program = parser(code, this._options);
                break;
            }
            catch (err) {
                if (!parseError) {
                    parseError = err;
                }
            }
        }
        if (!program && parseError) {
            throw parseError;
        }
        /* istanbul ignore next */
        return ('ast' in program && program.ast ? program : { ast: program });
    }
    // fix adjacent JSX nodes
    // @internal
    // eslint-disable-next-line sonarjs/cognitive-complexity
    _normalizeJsxNodes(node, options) {
        const value = node.value;
        let program;
        try {
            // wrap into single element which is valid jsx but not valid jsx in mdx, so that it won't break on adjacent JSX nodes
            program = this._eslintParse(`${JSX_WRAPPER_START}${value}${JSX_WRAPPER_END}`, options).ast;
        }
        catch (err) {
            if ((0, helpers_1.hasProperties)(err, exports.LOC_ERROR_PROPERTIES)) {
                const { position: { start }, } = node;
                /* istanbul ignore else */
                if ('index' in err) {
                    err.index += start.offset - OFFSET;
                }
                else if ('pos' in err) {
                    err.pos += start.offset - OFFSET;
                }
                err.column =
                    /* istanbul ignore next */
                    err.lineNumber > 1 ? err.column : err.column + start.column - OFFSET;
                err.lineNumber += start.line - 1;
                throw err;
            }
            return node;
        }
        const { expression } = program.body[0];
        if (!(0, helpers_1.isJsxNode)(expression) || expression.children.length <= 1) {
            return node;
        }
        const { position: { start: { line, offset }, }, data, } = node;
        return expression.children.reduce((nodes, jsNode) => {
            if (!(0, helpers_1.isJsxNode)(jsNode)) {
                return nodes;
            }
            /* istanbul ignore next */
            const { start: nodeStart, end: nodeEnd, loc: { start, end } = {
                start: { column: nodeStart, line: 1 },
                end: { column: nodeEnd, line: 1 },
            }, range = [nodeStart, nodeEnd], } = jsNode;
            const startLine = line + start.line - 1;
            const endLine = line + end.line - 1;
            const startOffset = range[0] - OFFSET;
            const endOffset = range[1] - OFFSET;
            nodes.push({
                type: 'jsx',
                data: nodes.length > 0 ? null : data,
                value: value.slice(startOffset, endOffset),
                position: {
                    start: {
                        line: startLine,
                        column: line === startLine ? start.column - OFFSET : start.column,
                        offset: offset + startOffset,
                    },
                    end: {
                        line: endLine,
                        column: line === startLine ? end.column - OFFSET : end.column,
                        offset: offset + endOffset,
                    },
                },
            });
            return nodes;
        }, []);
    }
    // @internal
    _nodeToAst(code, node, options) {
        if (node.data && node.data.jsxType === 'JSXElementWithHTMLComments') {
            this._services.JSXElementsWithHTMLComments.push(node);
        }
        const value = node.value;
        const { loc, start, end } = (0, helpers_1.normalizePosition)(node.position);
        // fix #4
        if ((0, regexp_1.isComment)(value)) {
            const comment = regexp_1.COMMENT_CONTENT_REGEX.exec(value)[2];
            this._ast.comments.push({
                type: 'Block',
                value: comment,
                loc,
                range: [start, end],
            });
            return;
        }
        const startLine = loc.start.line - 1; // ! line is 1-indexed, change to 0-indexed to simplify usage
        let program;
        try {
            program = this._eslintParse(value, options).ast;
        }
        catch (e) {
            /* istanbul ignore if */
            if ((0, helpers_1.hasProperties)(e, exports.LOC_ERROR_PROPERTIES)) {
                // should be handled by `_normalizeJsxNodes`, just for robustness
                e.index += start;
                e.column = e.lineNumber > 1 ? e.column : e.column + loc.start.column;
                e.lineNumber += startLine;
            }
            throw e;
        }
        const startPoint = {
            line: startLine,
            // #279 related
            column: (0, helpers_1.getPositionAt)(code, start).column,
            offset: start,
        };
        for (const prop of exports.AST_PROPS)
            this._ast[prop].push(
            // ts doesn't understand the mixed type
            ...program[prop].map((item) => (0, helpers_1.restoreNodeLocation)(item, startPoint)));
    }
}
exports.Parser = Parser;
exports.parser = new Parser();
// eslint-disable-next-line @typescript-eslint/unbound-method
exports.parse = exports.parser.parse, exports.parseForESLint = exports.parser.parseForESLint;
//# sourceMappingURL=parser.js.map