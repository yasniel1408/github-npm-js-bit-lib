"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.remark = void 0;
const tslib_1 = require("tslib");
const path_1 = (0, tslib_1.__importDefault)(require("path"));
const eslint_mdx_1 = require("eslint-mdx");
const synckit_1 = require("synckit");
const vfile_1 = (0, tslib_1.__importDefault)(require("vfile"));
const workerPath = require.resolve('../worker');
// call `creatSyncFn` lazily for performance, it is already cached inside, related #323
const lazyRemark = {
    get processSync() {
        return (0, synckit_1.createSyncFn)(workerPath);
    },
};
const brokenCache = new WeakMap();
exports.remark = {
    meta: {
        type: 'layout',
        docs: {
            description: 'Linter integration with remark plugins',
            category: 'Stylistic Issues',
            recommended: true,
        },
        fixable: 'code',
    },
    create(context) {
        const filename = context.getFilename();
        const extname = path_1.default.extname(filename);
        const sourceCode = context.getSourceCode();
        const options = context.parserOptions;
        const isMdx = [
            ...eslint_mdx_1.DEFAULT_EXTENSIONS,
            ...(options.extensions || []),
        ].includes(extname);
        const isMarkdown = [
            ...eslint_mdx_1.MARKDOWN_EXTENSIONS,
            ...(options.markdownExtensions || []),
        ].includes(extname);
        return {
            // eslint-disable-next-line sonarjs/cognitive-complexity
            Program(node) {
                /* istanbul ignore if */
                if (!isMdx && !isMarkdown) {
                    return;
                }
                const ignoreRemarkConfig = Boolean(options.ignoreRemarkConfig);
                const physicalFilename = (0, eslint_mdx_1.getPhysicalFilename)(filename);
                const sourceText = sourceCode.getText(node);
                const remarkProcessor = (0, eslint_mdx_1.getRemarkProcessor)(physicalFilename, isMdx, ignoreRemarkConfig);
                const fileOptions = {
                    path: physicalFilename,
                    contents: sourceText,
                };
                const file = (0, vfile_1.default)(fileOptions);
                let fixedText;
                let broken = brokenCache.get(remarkProcessor);
                if (broken) {
                    const { messages, content } = lazyRemark.processSync(fileOptions, physicalFilename, isMdx, ignoreRemarkConfig);
                    file.messages = messages;
                    fixedText = content;
                }
                else {
                    try {
                        remarkProcessor.processSync(file);
                    }
                    catch (err) {
                        /* istanbul ignore else */
                        if (err.message ===
                            '`processSync` finished async. Use `process` instead') {
                            brokenCache.set(remarkProcessor, (broken = true));
                            const { messages, content } = lazyRemark.processSync(fileOptions, physicalFilename, isMdx, ignoreRemarkConfig);
                            file.messages = messages;
                            fixedText = content;
                        }
                        else if (!file.messages.includes(err)) {
                            file.message(
                            // @ts-expect-error Error is fine
                            err).fatal = true;
                        }
                    }
                }
                if (!broken) {
                    fixedText = file.toString();
                }
                let fixed = 0;
                for (const { source, reason, ruleId, fatal, location: { start, end }, } of file.messages) {
                    // https://github.com/remarkjs/remark-lint/issues/65#issuecomment-220800231
                    /* istanbul ignore next */
                    const severity = fatal ? 2 : fatal == null ? 0 : 1;
                    /* istanbul ignore if */
                    if (!severity) {
                        // should never happen, just for robustness
                        continue;
                    }
                    const message = {
                        reason,
                        source,
                        ruleId,
                        severity,
                    };
                    context.report({
                        // related to https://github.com/eslint/eslint/issues/14198
                        message: JSON.stringify(message),
                        loc: {
                            // ! eslint ast column is 0-indexed, but unified is 1-indexed
                            start: Object.assign(Object.assign({}, start), { column: start.column - 1 }),
                            end: Object.assign(Object.assign({}, end), { column: end.column - 1 }),
                        },
                        node,
                        fix: fixedText === sourceText
                            ? null
                            : () => fixed++
                                ? null
                                : {
                                    range: [0, sourceText.length],
                                    text: fixedText,
                                },
                    });
                }
            },
        };
    },
};
//# sourceMappingURL=remark.js.map