import { arrayify, last, isJsxNode, DEFAULT_EXTENSIONS, MARKDOWN_EXTENSIONS, getPhysicalFilename, getRemarkProcessor } from 'eslint-mdx';
import { version } from 'eslint/package.json';
import { processors } from 'eslint-plugin-markdown';
import path from 'path';
import { createSyncFn } from 'synckit';
import vfile from 'vfile';

const base = {
  parser: "eslint-mdx",
  plugins: ["mdx"],
  processor: "mdx/remark"
};

const codeBlocks = {
  parserOptions: {
    ecmaFeatures: {
      impliedStrict: true
    }
  },
  rules: {
    "eol-last": "off",
    "no-undef": "off",
    "no-unused-expressions": "off",
    "no-unused-vars": "off",
    "padded-blocks": "off",
    strict: "off",
    "unicode-bom": "off"
  }
};

var __defProp$5 = Object.defineProperty;
var __defProps$4 = Object.defineProperties;
var __getOwnPropDescs$4 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$5 = Object.getOwnPropertySymbols;
var __hasOwnProp$5 = Object.prototype.hasOwnProperty;
var __propIsEnum$5 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$5 = (obj, key, value) => key in obj ? __defProp$5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$5 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$5.call(b, prop))
      __defNormalProp$5(a, prop, b[prop]);
  if (__getOwnPropSymbols$5)
    for (var prop of __getOwnPropSymbols$5(b)) {
      if (__propIsEnum$5.call(b, prop))
        __defNormalProp$5(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$4 = (a, b) => __defProps$4(a, __getOwnPropDescs$4(b));
let isReactPluginAvailable = false;
try {
  require.resolve("eslint-plugin-react");
  isReactPluginAvailable = true;
} catch (e) {
}
const overrides = __spreadProps$4(__spreadValues$5({}, base), {
  globals: {
    React: false
  },
  plugins: arrayify(base.plugins, isReactPluginAvailable ? "react" : null),
  rules: {
    "lines-between-class-members": 0,
    "react/jsx-no-undef": isReactPluginAvailable ? [
      2,
      {
        allowGlobals: true
      }
    ] : 0,
    "react/react-in-jsx-scope": 0
  }
});

var __defProp$4 = Object.defineProperty;
var __defProps$3 = Object.defineProperties;
var __getOwnPropDescs$3 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$4 = Object.getOwnPropertySymbols;
var __hasOwnProp$4 = Object.prototype.hasOwnProperty;
var __propIsEnum$4 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$4 = (obj, key, value) => key in obj ? __defProp$4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$4 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$4.call(b, prop))
      __defNormalProp$4(a, prop, b[prop]);
  if (__getOwnPropSymbols$4)
    for (var prop of __getOwnPropSymbols$4(b)) {
      if (__propIsEnum$4.call(b, prop))
        __defNormalProp$4(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$3 = (a, b) => __defProps$3(a, __getOwnPropDescs$3(b));
const minorVersion = +version.split(".").slice(0, 2).join(".");
const recommended = __spreadProps$3(__spreadValues$4({}, base), {
  rules: {
    "mdx/no-jsx-html-comments": 2,
    "mdx/no-unused-expressions": 2,
    "mdx/remark": 1,
    "no-unused-expressions": 0
  }
});
const OVERRIDES_AVAILABLE_VERSION = 6.4;
if (minorVersion >= OVERRIDES_AVAILABLE_VERSION) {
  const overrides = [
    {
      files: "*.mdx",
      extends: "plugin:mdx/overrides"
    },
    {
      files: "**/*.{md,mdx}/**",
      extends: "plugin:mdx/code-blocks"
    }
  ];
  try {
    require.resolve("prettier");
    require.resolve("eslint-plugin-prettier");
    overrides.push({
      files: "*.md",
      rules: {
        "prettier/prettier": [
          2,
          {
            parser: "markdown"
          }
        ]
      }
    }, {
      files: "*.mdx",
      rules: {
        "prettier/prettier": [
          2,
          {
            parser: "mdx"
          }
        ]
      }
    });
  } catch (e) {
  }
  Object.assign(recommended, {
    overrides
  });
}

const configs = {
  base,
  "code-blocks": codeBlocks,
  codeBlocks,
  overrides,
  recommended
};

const getGlobals = (sources, initialGlobals = {}) => (Array.isArray(sources) ? sources : Object.keys(sources)).reduce((globals, source) => Object.assign(globals, {
  [source]: false
}), initialGlobals);
const PRIVATE_API_VERSION = 8;
const getBuiltinRule = (ruleId) => {
  const { version: eslintVersion } = require("eslint/package.json");
  const majorVersion = Number.parseInt(eslintVersion.split(".")[0], 10);
  if (majorVersion < PRIVATE_API_VERSION) {
    return require(`eslint/lib/rules/${ruleId}`);
  }
  return require("eslint/use-at-your-own-risk").builtinRules.get(ruleId);
};

var __defProp$3 = Object.defineProperty;
var __getOwnPropSymbols$3 = Object.getOwnPropertySymbols;
var __hasOwnProp$3 = Object.prototype.hasOwnProperty;
var __propIsEnum$3 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$3 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$3.call(b, prop))
      __defNormalProp$3(a, prop, b[prop]);
  if (__getOwnPropSymbols$3)
    for (var prop of __getOwnPropSymbols$3(b)) {
      if (__propIsEnum$3.call(b, prop))
        __defNormalProp$3(a, prop, b[prop]);
    }
  return a;
};
const DEFAULT_LANGUAGE_MAPPER = {
  javascript: "js",
  javascriptreact: "jsx",
  typescript: "ts",
  typescriptreact: "tsx",
  markdown: "md",
  mdown: "md",
  mkdn: "md"
};
function getShortLang(filename, languageMapper) {
  const language = last(filename.split("."));
  if (languageMapper === false) {
    return language;
  }
  languageMapper = __spreadValues$3(__spreadValues$3({}, DEFAULT_LANGUAGE_MAPPER), languageMapper);
  const lang = language.toLowerCase();
  return languageMapper[language] || languageMapper[lang] || lang;
}

const processorOptions = {};
const linterPath = Object.keys(require.cache).find((path) => /([/\\])eslint\1lib(?:\1linter){2}\.js$/.test(path));
if (!linterPath) {
  throw new Error("Could not find ESLint Linter in require cache");
}
const ESLinter = require(linterPath).Linter;
const { verify } = ESLinter.prototype;
ESLinter.prototype.verify = function(code, config, options) {
  const settings = config && (typeof config.extractConfig === "function" ? config.extractConfig(typeof options === "undefined" || typeof options === "string" ? options : options.filename) : config).settings || {};
  processorOptions.lintCodeBlocks = settings["mdx/code-blocks"] === true;
  processorOptions.languageMapper = settings["mdx/language-mapper"];
  return verify.call(this, code, config, options);
};

var __defProp$2 = Object.defineProperty;
var __defProps$2 = Object.defineProperties;
var __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;
var __hasOwnProp$2 = Object.prototype.hasOwnProperty;
var __propIsEnum$2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$2 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$2.call(b, prop))
      __defNormalProp$2(a, prop, b[prop]);
  if (__getOwnPropSymbols$2)
    for (var prop of __getOwnPropSymbols$2(b)) {
      if (__propIsEnum$2.call(b, prop))
        __defNormalProp$2(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$2 = (a, b) => __defProps$2(a, __getOwnPropDescs$2(b));
const remark$1 = {
  supportsAutofix: true,
  preprocess(text, filename) {
    if (!processorOptions.lintCodeBlocks) {
      return [text];
    }
    return [
      text,
      ...processors.markdown.preprocess(text, filename).map(({ text: text2, filename: filename2 }) => ({
        text: text2,
        filename: filename2.slice(0, filename2.lastIndexOf(".")) + "." + getShortLang(filename2, processorOptions.languageMapper)
      }))
    ];
  },
  postprocess([mdxMessages, ...markdownMessages], filename) {
    return [
      ...mdxMessages,
      ...processors.markdown.postprocess(markdownMessages, filename)
    ].map((lintMessage) => {
      const {
        message,
        ruleId: eslintRuleId,
        severity: eslintSeverity
      } = lintMessage;
      if (eslintRuleId !== "mdx/remark") {
        return lintMessage;
      }
      const { source, ruleId, reason, severity } = JSON.parse(message);
      return __spreadProps$2(__spreadValues$2({}, lintMessage), {
        ruleId: `${source}-${ruleId}`,
        message: reason,
        severity: Math.max(eslintSeverity, severity)
      });
    });
  }
};

var remark$2 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  remark: remark$1
});

const noJsxHtmlComments = {
  meta: {
    type: "problem",
    docs: {
      description: "Forbid invalid html style comments in jsx block",
      category: "SyntaxError",
      recommended: true
    },
    messages: {
      jsxHtmlComments: "html style comments are invalid in jsx: {{ origin }}"
    },
    fixable: "code"
  },
  create(context) {
    return {
      ExpressionStatement(node) {
        const { JSXElementsWithHTMLComments: invalidNodes } = context.parserServices;
        if (!isJsxNode(node.expression) || node.parent.type !== "Program" || !invalidNodes || invalidNodes.length === 0) {
          return;
        }
        const invalidNode = invalidNodes.shift();
        if (invalidNode.data.inline) {
          return;
        }
        const comments = invalidNode.data.comments;
        for (const { fixed, loc, origin } of comments) {
          context.report({
            messageId: "jsxHtmlComments",
            data: {
              origin
            },
            loc,
            node,
            fix(fixer) {
              return fixer.replaceTextRange([loc.start.offset, loc.end.offset], fixed);
            }
          });
        }
      }
    };
  }
};

var __defProp$1 = Object.defineProperty;
var __defProps$1 = Object.defineProperties;
var __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1.call(b, prop))
      __defNormalProp$1(a, prop, b[prop]);
  if (__getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(b)) {
      if (__propIsEnum$1.call(b, prop))
        __defNormalProp$1(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));
const esLintNoUnusedExpressions = getBuiltinRule("no-unused-expressions");
const noUnusedExpressions = __spreadProps$1(__spreadValues$1({}, esLintNoUnusedExpressions), {
  create(context) {
    const esLintRuleListener = esLintNoUnusedExpressions.create(context);
    return {
      ExpressionStatement(node) {
        if (isJsxNode(node.expression) && node.parent.type === "Program") {
          return;
        }
        esLintRuleListener.ExpressionStatement(node);
      }
    };
  }
});

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
const workerPath = require.resolve("../worker");
const lazyRemark = {
  get processSync() {
    return createSyncFn(workerPath);
  }
};
const brokenCache = new WeakMap();
const remark = {
  meta: {
    type: "layout",
    docs: {
      description: "Linter integration with remark plugins",
      category: "Stylistic Issues",
      recommended: true
    },
    fixable: "code"
  },
  create(context) {
    const filename = context.getFilename();
    const extname = path.extname(filename);
    const sourceCode = context.getSourceCode();
    const options = context.parserOptions;
    const isMdx = [
      ...DEFAULT_EXTENSIONS,
      ...options.extensions || []
    ].includes(extname);
    const isMarkdown = [
      ...MARKDOWN_EXTENSIONS,
      ...options.markdownExtensions || []
    ].includes(extname);
    return {
      Program(node) {
        if (!isMdx && !isMarkdown) {
          return;
        }
        const ignoreRemarkConfig = Boolean(options.ignoreRemarkConfig);
        const physicalFilename = getPhysicalFilename(filename);
        const sourceText = sourceCode.getText(node);
        const remarkProcessor = getRemarkProcessor(physicalFilename, isMdx, ignoreRemarkConfig);
        const fileOptions = {
          path: physicalFilename,
          contents: sourceText
        };
        const file = vfile(fileOptions);
        let fixedText;
        let broken = brokenCache.get(remarkProcessor);
        if (broken) {
          const { messages, content } = lazyRemark.processSync(fileOptions, physicalFilename, isMdx, ignoreRemarkConfig);
          file.messages = messages;
          fixedText = content;
        } else {
          try {
            remarkProcessor.processSync(file);
          } catch (err) {
            if (err.message === "`processSync` finished async. Use `process` instead") {
              brokenCache.set(remarkProcessor, broken = true);
              const { messages, content } = lazyRemark.processSync(fileOptions, physicalFilename, isMdx, ignoreRemarkConfig);
              file.messages = messages;
              fixedText = content;
            } else if (!file.messages.includes(err)) {
              file.message(err).fatal = true;
            }
          }
        }
        if (!broken) {
          fixedText = file.toString();
        }
        let fixed = 0;
        for (const {
          source,
          reason,
          ruleId,
          fatal,
          location: { start, end }
        } of file.messages) {
          const severity = fatal ? 2 : fatal == null ? 0 : 1;
          if (!severity) {
            continue;
          }
          const message = {
            reason,
            source,
            ruleId,
            severity
          };
          context.report({
            message: JSON.stringify(message),
            loc: {
              start: __spreadProps(__spreadValues({}, start), {
                column: start.column - 1
              }),
              end: __spreadProps(__spreadValues({}, end), {
                column: end.column - 1
              })
            },
            node,
            fix: fixedText === sourceText ? null : () => fixed++ ? null : {
              range: [0, sourceText.length],
              text: fixedText
            }
          });
        }
      }
    };
  }
};

const rules = {
  "no-jsx-html-comments": noJsxHtmlComments,
  "no-unused-expressions": noUnusedExpressions,
  noJsxHtmlComments,
  noUnusedExpressions,
  remark
};

export { DEFAULT_LANGUAGE_MAPPER, base, codeBlocks, configs, getBuiltinRule, getGlobals, getShortLang, noJsxHtmlComments, noUnusedExpressions, overrides, processorOptions, remark$2 as processors, recommended, remark, rules };
