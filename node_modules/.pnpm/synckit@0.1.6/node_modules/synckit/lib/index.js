"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.runAsWorker = exports.createSyncFn = exports.tmpdir = void 0;
const tslib_1 = require("tslib");
const child_process_1 = require("child_process");
const os_1 = require("os");
const path_1 = tslib_1.__importDefault(require("path"));
const fs_1 = tslib_1.__importDefault(require("fs"));
const uuid_1 = require("uuid");
tslib_1.__exportStar(require("./types"), exports);
/**
 * @link https://github.com/sindresorhus/temp-dir/blob/main/index.js#L9
 */
exports.tmpdir = fs_1.default.realpathSync(os_1.tmpdir());
let tsconfigPathsAvailable;
const TSCONFIG_PATH = process.env.TSCONFIG_PATH || 'tsconfig.json';
const isTsconfigPathsAvailable = () => {
    if (typeof tsconfigPathsAvailable === 'boolean') {
        return tsconfigPathsAvailable;
    }
    try {
        tsconfigPathsAvailable = !!require.resolve('tsconfig-paths');
    }
    catch (_a) {
        /**
         * `require.resolve` can not be mocked to fail
         * @link https://github.com/facebook/jest/issues/9543
         */
        /* istanbul ignore next */
        tsconfigPathsAvailable = false;
    }
    return tsconfigPathsAvailable;
};
const syncFnCache = new Map();
function createSyncFn(workerPath) {
    if (!path_1.default.isAbsolute(workerPath)) {
        throw new Error('`workerPath` must be absolute');
    }
    const cachedSyncFn = syncFnCache.get(workerPath);
    if (cachedSyncFn) {
        return cachedSyncFn;
    }
    let resolvedWorkerPath = workerPath;
    if (!resolvedWorkerPath.endsWith('.ts')) {
        resolvedWorkerPath = require.resolve(workerPath);
    }
    const executor = resolvedWorkerPath.endsWith('.ts')
        ? 'ts-node -P ' +
            TSCONFIG_PATH +
            (isTsconfigPathsAvailable()
                ? ' -r tsconfig-paths/register'
                : /* istanbul ignore next */ '')
        : 'node';
    const syncFn = (...args) => {
        const filename = path_1.default.resolve(exports.tmpdir, `synckit-${uuid_1.v4()}.json`);
        fs_1.default.writeFileSync(filename, JSON.stringify(args));
        const command = `${executor} ${resolvedWorkerPath} ${filename}`;
        try {
            child_process_1.execSync(command, {
                stdio: 'inherit',
            });
            const result = fs_1.default.readFileSync(filename, 'utf8');
            return JSON.parse(result);
        }
        finally {
            fs_1.default.unlinkSync(filename);
        }
    };
    syncFnCache.set(workerPath, syncFn);
    return syncFn;
}
exports.createSyncFn = createSyncFn;
const runAsWorker = (fn) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const filename = process.argv[2];
    const content = fs_1.default.readFileSync(filename, 'utf-8');
    const options = JSON.parse(content);
    fs_1.default.writeFileSync(filename, JSON.stringify(yield fn(...options)));
});
exports.runAsWorker = runAsWorker;
//# sourceMappingURL=index.js.map