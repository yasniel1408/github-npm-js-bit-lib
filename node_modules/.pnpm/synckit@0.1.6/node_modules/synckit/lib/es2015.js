import { execSync } from 'child_process';
import { tmpdir as tmpdir$1 } from 'os';
import path from 'path';
import fs from 'fs';
import { v4 } from 'uuid';

var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const tmpdir = fs.realpathSync(tmpdir$1());
let tsconfigPathsAvailable;
const TSCONFIG_PATH = process.env.TSCONFIG_PATH || "tsconfig.json";
const isTsconfigPathsAvailable = () => {
  if (typeof tsconfigPathsAvailable === "boolean") {
    return tsconfigPathsAvailable;
  }
  try {
    tsconfigPathsAvailable = !!require.resolve("tsconfig-paths");
  } catch (e) {
    tsconfigPathsAvailable = false;
  }
  return tsconfigPathsAvailable;
};
const syncFnCache = new Map();
function createSyncFn(workerPath) {
  if (!path.isAbsolute(workerPath)) {
    throw new Error("`workerPath` must be absolute");
  }
  const cachedSyncFn = syncFnCache.get(workerPath);
  if (cachedSyncFn) {
    return cachedSyncFn;
  }
  let resolvedWorkerPath = workerPath;
  if (!resolvedWorkerPath.endsWith(".ts")) {
    resolvedWorkerPath = require.resolve(workerPath);
  }
  const executor = resolvedWorkerPath.endsWith(".ts") ? "ts-node -P " + TSCONFIG_PATH + (isTsconfigPathsAvailable() ? " -r tsconfig-paths/register" : "") : "node";
  const syncFn = (...args) => {
    const filename = path.resolve(tmpdir, `synckit-${v4()}.json`);
    fs.writeFileSync(filename, JSON.stringify(args));
    const command = `${executor} ${resolvedWorkerPath} ${filename}`;
    try {
      execSync(command, {
        stdio: "inherit"
      });
      const result = fs.readFileSync(filename, "utf8");
      return JSON.parse(result);
    } finally {
      fs.unlinkSync(filename);
    }
  };
  syncFnCache.set(workerPath, syncFn);
  return syncFn;
}
const runAsWorker = (fn) => __async(undefined, null, function* () {
  const filename = process.argv[2];
  const content = fs.readFileSync(filename, "utf-8");
  const options = JSON.parse(content);
  fs.writeFileSync(filename, JSON.stringify(yield fn(...options)));
});

export { createSyncFn, runAsWorker, tmpdir };
