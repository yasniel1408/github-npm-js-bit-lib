"use strict";
/* eslint-disable no-console */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getResultFromFiles = exports.getConfig = exports.patternsToArray = void 0;
const path_1 = require("path");
const minimatch_1 = __importDefault(require("minimatch"));
const lodash_1 = require("lodash");
const tester_1 = require("@teambit/tester");
const tests_results_1 = require("@teambit/tests-results");
const component_1 = require("@teambit/component");
const vite_esm_packages_vite_1 = __importDefault(require("@teambit/vite.esm-packages.vite"));
const vitest_error_1 = require("./vitest-error");
// pattern utils
const resolvePattern = (pattern, rootDirs) => {
    return rootDirs.map((dir) => (0, path_1.resolve)(dir, pattern));
};
const resolveComponentPattern = (component, patternEntry, opts, context) => {
    if (opts.resolveSpecPaths) {
        return opts.resolveSpecPaths(component, context);
    }
    const customPatterns = opts.patterns;
    // If pattern were provided to the specific instance of the tester, use them
    if (customPatterns && !(0, lodash_1.isEmpty)(customPatterns)) {
        customPatterns.map((customPattern) => {
            const rootDirs = opts.roots || [patternEntry.componentDir];
            return resolvePattern(customPattern, rootDirs);
        });
    }
    return patternEntry.paths.map((p) => p.path);
};
// input utils
const patternsToArray = (opts, context) => {
    return (0, lodash_1.flatten)(context.patterns
        .toArray()
        .map(([component, patternEntry]) => resolveComponentPattern(component, patternEntry, opts, context)));
};
exports.patternsToArray = patternsToArray;
const getConfig = (configPath, context, depResolver, watch) => __awaiter(void 0, void 0, void 0, function* () {
    const packageNames = context.components.map((component) => depResolver.getPackageName(component));
    const defaultExclude = [
        '**/node_modules/**',
        '**/cypress/**',
        '**/.{idea,git,cache,output,temp}/**',
        '**/{karma,rollup,webpack,vite,vitest,jest,ava,babel,nyc,cypress,tsup,build}.config.*'
    ];
    const config = {
        root: context.rootPath,
        configFile: false,
        envFile: false,
        plugins: [],
        resolve: {
            mainFields: ['source', 'main', 'module', 'jsnext:main', 'jsnext'],
        },
        server: {
            fs: {
                strict: false
            }
        },
        test: {
            globals: true,
            environment: 'jsdom',
            root: context.rootPath,
            exclude: defaultExclude,
            cache: {
                dir: (0, path_1.resolve)(context.rootPath, 'node_modules', '.vitest'),
            },
            server: {
                deps: {
                    inline: packageNames,
                }
            },
            watchExclude: packageNames.map((m) => `!**/node_modules/${m}/**`)
        }
    };
    if (context.debug) {
        // Nothing to do with Vitest
    }
    if (context.coverage) {
        config.test.coverage = {
            provider: 'v8',
            enabled: true,
        };
    }
    config.test.watch = context.watch || watch;
    const { mergeConfig, loadConfigFromFile } = yield (0, vite_esm_packages_vite_1.default)();
    const vitestConfig = yield loadConfigFromFile({
        command: 'build',
        mode: 'development'
    }, configPath);
    const realVitestConfig = (vitestConfig === null || vitestConfig === void 0 ? void 0 : vitestConfig.config) || {};
    const result = mergeConfig(config, realVitestConfig);
    return result;
});
exports.getConfig = getConfig;
// output utils
const getTaskState = (status) => {
    switch (status) {
        case 'pass':
            return 'passed';
        case 'fail':
            return 'failed';
        case 'skip':
            return 'skipped';
        case 'todo':
            return 'todo';
        default:
            return 'pending';
    }
};
const traverseTask = (task, ancestor = []) => {
    var _a, _b, _c, _d, _e;
    const resultList = [];
    const info = {
        resultList,
        pass: 0,
        failed: 0,
        pending: 0,
        duration: 0,
        slow: false // TODO: calculate slow
    };
    if (task.type === 'test') {
        const error = (_b = (_a = task.result) === null || _a === void 0 ? void 0 : _a.errors) === null || _b === void 0 ? void 0 : _b[0];
        const errorStr = (error === null || error === void 0 ? void 0 : error.message) || (error === null || error === void 0 ? void 0 : error.stack);
        const status = getTaskState((_c = task.result) === null || _c === void 0 ? void 0 : _c.state);
        switch (status) {
            case 'passed':
                info.pass += 1;
                break;
            case 'failed':
                info.failed += 1;
                break;
            case 'pending':
                info.pending += 1;
                break;
            default:
                break;
        }
        const isFailure = status === 'failed';
        info.duration += ((_d = task.result) === null || _d === void 0 ? void 0 : _d.duration) || 0;
        resultList.push(new tests_results_1.TestResult(ancestor, task.name, status, (_e = task.result) === null || _e === void 0 ? void 0 : _e.duration, isFailure ? undefined : errorStr, isFailure ? errorStr : undefined));
    }
    if (task.type === 'suite') {
        task.tasks.forEach(subTask => {
            const subInfo = traverseTask(subTask, [...ancestor]);
            info.pass += subInfo.pass;
            info.failed += subInfo.failed;
            info.pending += subInfo.pending;
            info.duration += subInfo.duration;
            info.slow = info.slow || subInfo.slow;
            resultList.push(...subInfo.resultList);
        });
    }
    return info;
};
const genErrorsFromTests = (files, unhandledErrors) => {
    const errors = [];
    files.forEach(file => {
        file.tests.forEach(test => {
            if (test.error) {
                errors.push(new vitest_error_1.VitestError(test.error));
            }
            if (test.failure) {
                errors.push(new vitest_error_1.VitestError(test.failure));
            }
        });
    });
    unhandledErrors.forEach((error) => {
        errors.push(error);
    });
    return errors;
};
const getResultFromFiles = (files, errors, opts, testerContext) => {
    const componentMap = component_1.ComponentMap.as(testerContext.patterns.components, (component) => {
        const componentPatternValue = testerContext.patterns.get(component);
        if (!componentPatternValue)
            return [];
        const [currComponent, patternEntry] = componentPatternValue;
        const resolvedPatterns = resolveComponentPattern(currComponent, patternEntry, opts, testerContext);
        return files.filter(file => resolvedPatterns.filter((resolvedPattern) => (0, minimatch_1.default)(file.filepath, resolvedPattern)).length > 0);
    });
    const componentResults = componentMap.toArray().map(([component, componentFiles]) => {
        const componentPatternValue = testerContext.patterns.get(component);
        if (!componentPatternValue)
            return undefined;
        const [, patternEntry] = componentPatternValue;
        const tests = [];
        componentFiles.forEach(file => {
            const { resultList, pass, failed, pending, duration, slow } = traverseTask(file);
            tests.push(new tests_results_1.TestsFiles((0, path_1.relative)(patternEntry.componentDir, file.filepath), resultList, pass, failed, pending, duration, slow, undefined));
        });
        return {
            componentId: component.id,
            results: new tests_results_1.TestsResult(tests, true, 0),
            errors: genErrorsFromTests(tests, errors),
        };
    });
    const result = (0, lodash_1.compact)(componentResults);
    return new tester_1.Tests(result);
};
exports.getResultFromFiles = getResultFromFiles;
//# sourceMappingURL=utils.js.map