/* eslint-disable no-console */

import { relative, resolve } from 'path';
import minimatch from 'minimatch';
import { compact, flatten, isEmpty } from 'lodash';
import {
  TesterContext,
  Tests,
  ComponentPatternsEntry,
} from '@teambit/tester';
import { TestsFiles, TestResult, TestsResult } from '@teambit/tests-results';
import { Component, ComponentMap } from '@teambit/component';
import { DependencyResolverMain } from '@teambit/dependency-resolver';
import type { Vitest } from  'vitest/node';
import getVitest from '@teambit/vite.esm-packages.vite';
import type { InlineConfig as ViteConfig } from 'vite';
import { VitestError } from './vitest-error';
import { VitestTesterOptions } from './vitest-options';

// types

// https://stackoverflow.com/a/51399781
type ArrayElement<ArrayType extends readonly unknown[]> = 
  ArrayType extends readonly (infer ElementType)[] ? ElementType : never;

export type VitestFile = ArrayElement<ReturnType<Vitest['state']['getFiles']>>;

type VitestTask = ArrayElement<VitestFile['tasks']>;

type VitestTaskState = 'run' | 'skip' | 'only' | 'todo' | 'pass' | 'fail';

// pattern utils

const resolvePattern = (pattern: string, rootDirs: string[]) => {
  return rootDirs.map((dir) => resolve(dir, pattern));
}

const resolveComponentPattern = (
  component: Component,
  patternEntry: ComponentPatternsEntry,
  opts: VitestTesterOptions,
  context: TesterContext
): string[] => {
  if (opts.resolveSpecPaths) {
    return opts.resolveSpecPaths(component, context);
  }
  const customPatterns = opts.patterns;
  // If pattern were provided to the specific instance of the tester, use them
  if (customPatterns && !isEmpty(customPatterns)) {
    customPatterns.map((customPattern) => {
      const rootDirs = opts.roots || [patternEntry.componentDir];
      return resolvePattern(customPattern, rootDirs);
    });
  }

  return patternEntry.paths.map((p) => p.path);
}

// input utils

export const patternsToArray = (
  opts: VitestTesterOptions,
  context: TesterContext
): string[] => {
  return flatten(
    context.patterns
      .toArray()
      .map(([component, patternEntry]) =>
        resolveComponentPattern(component, patternEntry, opts, context)
      )
  );
}

export const getConfig = async (configPath: string, context: TesterContext, depResolver: DependencyResolverMain, watch?: boolean): Promise<ViteConfig> => {
  const packageNames = context.components.map((component) => depResolver.getPackageName(component));
  const defaultExclude = [
    '**/node_modules/**',
    '**/cypress/**',
    '**/.{idea,git,cache,output,temp}/**',
    '**/{karma,rollup,webpack,vite,vitest,jest,ava,babel,nyc,cypress,tsup,build}.config.*'
  ];
  
  const config: ViteConfig = {
    root: context.rootPath,
    configFile: false,
    envFile: false,
    plugins: [],
    resolve: {
      mainFields: ['source', 'main', 'module', 'jsnext:main', 'jsnext'],
    },
    server: {
      fs: {
        strict: false
      }
    },
    test: {
      globals: true,
      environment: 'jsdom',
      root: context.rootPath,
      exclude: defaultExclude,
      cache: {
        dir: resolve(context.rootPath, 'node_modules', '.vitest'),
      },
      server: {
        deps: {
          inline: packageNames,
        }
      },
      watchExclude: packageNames.map((m) => `!**/node_modules/${m}/**`)
    }
  };

  if (context.debug) {
    // Nothing to do with Vitest
  }
  if (context.coverage) {
    config.test!.coverage = {
      provider: 'v8',
      enabled: true,
    };
  }
  config.test!.watch = context.watch || watch;

  const { mergeConfig, loadConfigFromFile } = await getVitest();
  const vitestConfig = await loadConfigFromFile({
    command: 'build',
    mode: 'development'
  }, configPath)
  const realVitestConfig: ViteConfig = vitestConfig?.config || {};
  const result = mergeConfig(config, realVitestConfig);
  return result;
};

// output utils

const getTaskState = (status: VitestTaskState | undefined): TestResult["status"] => {
  switch (status) {
    case 'pass':
      return 'passed';
    case 'fail':
      return 'failed';
    case 'skip':
      return 'skipped';
    case 'todo':
      return 'todo';
    default:
      return 'pending';
  }
}

const traverseTask = (task: VitestTask, ancestor: string[] = []) => {
  const resultList: TestResult[] = [];
  const info = {
    resultList,
    pass: 0,
    failed: 0,
    pending: 0,
    duration: 0,
    slow: false // TODO: calculate slow
  };
  if (task.type === 'test') {
    const error = task.result?.errors?.[0];
    const errorStr = error?.message || error?.stack;
    const status = getTaskState(task.result?.state);
    switch (status) {
      case 'passed':
        info.pass += 1;
        break;
      case 'failed':
        info.failed += 1;
        break;
      case 'pending':
        info.pending += 1;
        break;
      default:
        break;
    }
    const isFailure = status === 'failed';
    info.duration += task.result?.duration || 0;
    resultList.push(new TestResult(
      ancestor,
      task.name,
      status,
      task.result?.duration,
      isFailure ? undefined : errorStr,
      isFailure ? errorStr : undefined
));
  }
  if (task.type === 'suite') {
    task.tasks.forEach(subTask => {
      const subInfo = traverseTask(subTask, [...ancestor]);
      info.pass += subInfo.pass;
      info.failed += subInfo.failed;
      info.pending += subInfo.pending;
      info.duration += subInfo.duration;
      info.slow = info.slow || subInfo.slow;
      resultList.push(...subInfo.resultList);
    });
  }
  return info;
}

const genErrorsFromTests = (files: TestsFiles[], unhandledErrors: unknown[]): VitestError[] => {
  const errors: VitestError[] = [];
  files.forEach(file => {
    file.tests.forEach(test => {
      if (test.error) {
        errors.push(new VitestError(test.error));
      }

      if (test.failure) {
        errors.push(new VitestError(test.failure));
      }
    });
  });
  unhandledErrors.forEach((error) => {
    errors.push(error as Error);
  });
  return errors;
};

export const getResultFromFiles = (
  files: VitestFile[],
  errors: unknown[],
  opts: VitestTesterOptions,
  testerContext: TesterContext
): Tests => {
  const componentMap = ComponentMap.as(testerContext.patterns.components, (component) => {
    const componentPatternValue = testerContext.patterns.get(component);
    if (!componentPatternValue) return [];
    const [currComponent, patternEntry] = componentPatternValue;
    const resolvedPatterns = resolveComponentPattern(
      currComponent,
      patternEntry,
      opts,
      testerContext
    );
    return files.filter(
      file =>
        resolvedPatterns.filter((resolvedPattern) =>
          minimatch(file.filepath, resolvedPattern)
        ).length > 0
    );
  });
  const componentResults = componentMap.toArray().map(([component, componentFiles]) => {
    const componentPatternValue = testerContext.patterns.get(component);
    if (!componentPatternValue) return undefined;
    const [, patternEntry] = componentPatternValue;
    const tests: TestsFiles[] = []
    componentFiles!.forEach(file => {
      const { resultList, pass, failed, pending, duration, slow } = traverseTask(file);
      tests.push(new TestsFiles(
        relative(patternEntry.componentDir, file.filepath),
        resultList,
        pass,
        failed,
        pending,
        duration,
        slow,
        undefined
      ));
    })
    return {
      componentId: component.id,
      results: new TestsResult(tests, true, 0),
      errors: genErrorsFromTests(tests, errors),
    };
  });
  const result = compact(componentResults);
  return new Tests(result);
}
