"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PrettierFormatter = void 0;
const prettier_1 = __importDefault(require("prettier"));
const lodash_1 = require("lodash");
const p_map_series_1 = __importDefault(require("p-map-series"));
const get_prettier_config_1 = require("./get-prettier-config");
const DEFAULT_EXTENSIONS = [
    '.js',
    '.jsx',
    '.ts',
    '.tsx',
    '.mjs',
    '.cjs',
    '.json',
    '.css',
    '.scss',
    '.md',
    '.mdx',
    '.html',
    '.yml',
    '.yaml',
];
class PrettierFormatter {
    constructor(id = 'prettier-formatter', logger, options, 
    /**
     * file types to format.
     */
    extensions = DEFAULT_EXTENSIONS, 
    /**
     * reference to the prettier module.
     */
    prettierModule = prettier_1.default) {
        this.id = id;
        this.logger = logger;
        this.options = options;
        this.extensions = extensions;
        this.prettierModule = prettierModule;
        // eslint-disable-next-line react/static-property-placement
        this.displayName = 'Prettier';
    }
    displayConfig() {
        return JSON.stringify(this.options, null, 2);
    }
    format(context) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.run(context);
        });
    }
    formatSnippet(snippet) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.prettierModule.format(snippet, this.options);
        });
    }
    check(context) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.run(context);
        });
    }
    run(context) {
        return __awaiter(this, void 0, void 0, function* () {
            const check = !!context.check;
            const longProcessLogger = this.logger.createLongProcessLogger('formatting components', context.components.length);
            const resultsP = (0, p_map_series_1.default)(context.components, (component) => __awaiter(this, void 0, void 0, function* () {
                longProcessLogger.logProgress(component.id.toString());
                const filesP = component.filesystem.files.map((file) => __awaiter(this, void 0, void 0, function* () {
                    var _a;
                    if (!((_a = this.extensions) === null || _a === void 0 ? void 0 : _a.includes(file.extname)))
                        return undefined;
                    const sourceCode = file.contents.toString('utf8');
                    const optsWithFilePath = this.addFilePathToOpts(this.options, file);
                    const checkFormatResults = yield this.prettierModule.check(sourceCode, optsWithFilePath);
                    const formatResults = yield this.prettierModule.format(sourceCode, optsWithFilePath);
                    const hasIssues = !checkFormatResults;
                    const newContent = typeof formatResults === 'string' && hasIssues
                        ? formatResults
                        : undefined;
                    if (!check && newContent) {
                        // eslint-disable-next-line no-param-reassign
                        file.contents = Buffer.from(newContent);
                        yield file.write(undefined, true);
                    }
                    return {
                        filePath: file.relative,
                        hasIssues,
                        newContent,
                    };
                }));
                const files = yield Promise.all(filesP);
                return {
                    component,
                    results: (0, lodash_1.compact)(files),
                };
            }));
            const results = yield resultsP;
            return {
                results,
                errors: [],
            };
        });
    }
    addFilePathToOpts(options, file) {
        return Object.assign(Object.assign({}, options), { filepath: file.path });
    }
    version() {
        return this.prettierModule.version;
    }
    static from(options) {
        return (context) => {
            const name = options.name || 'prettier-formatter';
            const logger = context.createLogger(name);
            const prettierConfig = (0, get_prettier_config_1.computePrettierConfig)(options);
            return new PrettierFormatter(name, logger, prettierConfig, options.extensions, options.prettier || prettier_1.default);
        };
    }
}
exports.PrettierFormatter = PrettierFormatter;
//# sourceMappingURL=prettier-formatter.js.map