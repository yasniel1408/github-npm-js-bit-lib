"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypescriptCompiler = void 0;
const typescript_1 = __importDefault(require("typescript"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const bit_error_1 = require("@teambit/bit-error");
const package_json_file_1 = __importDefault(require("@teambit/legacy/dist/consumer/component/package-json-file"));
const get_ts_config_1 = require("./get-ts-config");
const resolve_types_1 = require("./resolve-types");
class TypescriptCompiler {
    constructor(id = 'typescript-compiler', logger, options, rawTsConfig, tsModule) {
        var _a, _b;
        var _c, _d, _e;
        this.id = id;
        this.logger = logger;
        this.options = options;
        this.rawTsConfig = rawTsConfig;
        this.tsModule = tsModule;
        // eslint-disable-next-line react/static-property-placement
        this.displayName = 'TypeScript';
        this.deleteDistDir = false;
        this.distDir = options.distDir || 'dist';
        this.distGlobPatterns = options.distGlobPatterns || [
            `${this.distDir}/**`,
            `!${this.distDir}/tsconfig.tsbuildinfo`,
        ];
        this.shouldCopyNonSupportedFiles =
            typeof options.shouldCopyNonSupportedFiles === 'boolean'
                ? options.shouldCopyNonSupportedFiles
                : true;
        this.artifactName = options.artifactName || 'dist';
        this.rawTsConfig || (this.rawTsConfig = {});
        (_c = this.rawTsConfig).compilerOptions || (_c.compilerOptions = {});
        // mutate the outDir, otherwise, on capsules, the dists might be written to a different directory and make confusion
        this.rawTsConfig.compilerOptions.outDir = this.distDir;
        this.options.types = this.options.types || this.getDefaultGlobalTypes();
        (_a = (_d = this.options).compileJs) !== null && _a !== void 0 ? _a : (_d.compileJs = true);
        (_b = (_e = this.options).compileJsx) !== null && _b !== void 0 ? _b : (_e.compileJsx = true);
    }
    /**
     * get the computed tsconfig for the instance.
     * TODO: @gilad support transformers here.
     */
    get tsconfig() {
        return this.rawTsConfig;
    }
    displayConfig() {
        return this.stringifyTsconfig(this.tsconfig);
    }
    getDistDir() {
        return this.distDir;
    }
    /**
     * compile one file on the workspace
     */
    transpileFile(fileContent, options) {
        if (!this.isFileSupported(options.filePath)) {
            return null; // file is not supported
        }
        const compilerOptionsFromTsconfig = this.tsModule.convertCompilerOptionsFromJson(this.rawTsConfig.compilerOptions, '.');
        if (compilerOptionsFromTsconfig.errors.length) {
            // :TODO @david replace to a more concrete error type and put in 'exceptions' directory here.
            const formattedErrors = this.tsModule.formatDiagnosticsWithColorAndContext(compilerOptionsFromTsconfig.errors, this.getFormatDiagnosticsHost());
            throw new Error(`failed parsing the tsconfig.json.\n${formattedErrors}`);
        }
        const compilerOptions = compilerOptionsFromTsconfig.options;
        compilerOptions.sourceRoot = options.componentDir;
        compilerOptions.rootDir = '.';
        const typescriptTransformers = this.options.typescriptTransformers || {};
        const fileName = this.getFilePathForTranspileFile(options.filePath);
        const result = this.tsModule.transpileModule(fileContent, {
            compilerOptions,
            fileName,
            reportDiagnostics: true,
            transformers: typescriptTransformers
        });
        if (result.diagnostics && result.diagnostics.length) {
            const formatHost = this.getFormatDiagnosticsHost();
            const error = this.tsModule.formatDiagnosticsWithColorAndContext(result.diagnostics, formatHost);
            // :TODO @david please replace to a more concrete error type and put in 'exceptions' directory here.
            throw new Error(error);
        }
        const outputPath = this.replaceFileExtToJs(options.filePath);
        const outputFiles = [{ outputText: result.outputText, outputPath }];
        if (result.sourceMapText) {
            outputFiles.push({
                outputText: result.sourceMapText,
                outputPath: `${outputPath}.map`,
            });
        }
        return outputFiles;
    }
    preBuild(context) {
        return __awaiter(this, void 0, void 0, function* () {
            const capsules = context.capsuleNetwork.seedersCapsules;
            const capsuleDirs = capsules.map((capsule) => capsule.path);
            yield this.writeTsConfig(capsuleDirs);
            yield this.writeTypes(capsuleDirs);
            yield this.writeNpmIgnore(capsuleDirs);
        });
    }
    /**
     * compile multiple components on the capsules
     */
    build(context) {
        return __awaiter(this, void 0, void 0, function* () {
            const componentsResults = yield this.runTscBuild(context.capsuleNetwork);
            return {
                artifacts: this.getArtifactDefinition(),
                componentsResults,
            };
        });
    }
    postBuild(context) {
        return __awaiter(this, void 0, void 0, function* () {
            yield Promise.all(context.capsuleNetwork.seedersCapsules.map((capsule) => __awaiter(this, void 0, void 0, function* () {
                const packageJson = package_json_file_1.default.loadFromCapsuleSync(capsule.path);
                // the types['index.ts'] is needed only during the build to avoid errors when tsc finds the
                // same type once in the d.ts and once in the ts file.
                if (packageJson.packageJsonObject.types) {
                    delete packageJson.packageJsonObject.types;
                    yield packageJson.write();
                }
            })));
        });
    }
    getArtifactDefinition() {
        return [
            {
                generatedBy: this.id,
                name: this.artifactName,
                globPatterns: this.distGlobPatterns,
            },
        ];
    }
    /**
     * given a source file, return its parallel in the dists. e.g. index.ts => dist/index.js
     */
    getDistPathBySrcPath(srcPath) {
        const fileWithJSExtIfNeeded = this.replaceFileExtToJs(srcPath);
        return path_1.default.join(this.distDir, fileWithJSExtIfNeeded);
    }
    /**
     * whether typescript is able to compile the given path
     */
    isFileSupported(filePath) {
        const isJsAndCompile = !!this.options.compileJs && filePath.endsWith('.js');
        const isJsxAndCompile = !!this.options.compileJsx && filePath.endsWith('.jsx');
        return ((filePath.endsWith('.ts') ||
            filePath.endsWith('.tsx') ||
            isJsAndCompile ||
            isJsxAndCompile) &&
            !filePath.endsWith('.d.ts'));
    }
    getFilePathForTranspileFile(origFilePath) {
        if (!this.options.esm)
            return origFilePath;
        const fileExtension = path_1.default.extname(origFilePath);
        if (fileExtension === '.js') {
            return origFilePath.replace(fileExtension, '.mjs');
        }
        if (fileExtension === '.ts') {
            return origFilePath.replace(fileExtension, '.mts');
        }
        return origFilePath;
    }
    /**
     * we have two options here:
     * 1. pass all capsules-dir at the second parameter of createSolutionBuilder and then no
     * need to write the main tsconfig.json with all the references.
     * 2. write main tsconfig.json and pass the capsules root-dir.
     * we went with option #2 because it'll be easier for users to go to the capsule-root and run
     * `tsc --build` to debug issues.
     */
    runTscBuild(network) {
        return __awaiter(this, void 0, void 0, function* () {
            const rootDir = network.capsulesRootDir;
            const capsules = yield network.getCapsulesToCompile();
            if (!capsules.length) {
                return [];
            }
            const capsuleDirs = capsules.getAllCapsuleDirs();
            const formatHost = {
                getCanonicalFileName: (p) => p,
                getCurrentDirectory: () => '',
                getNewLine: () => this.tsModule.sys.newLine,
            };
            const componentsResults = [];
            let currentComponentResult = { errors: [] };
            const reportDiagnostic = (diagnostic) => {
                const errorStr = process.stdout.isTTY
                    ? this.tsModule.formatDiagnosticsWithColorAndContext([diagnostic], formatHost)
                    : this.tsModule.formatDiagnostic(diagnostic, formatHost);
                if (!diagnostic.file) {
                    // the error is general and not related to a specific file. e.g. tsconfig is missing.
                    throw new bit_error_1.BitError(errorStr);
                }
                this.logger.consoleFailure(errorStr);
                if (!currentComponentResult.component || !currentComponentResult.errors) {
                    throw new Error(`currentComponentResult is not defined yet for ${diagnostic.file}`);
                }
                currentComponentResult.errors.push(errorStr);
            };
            // this only works when `verbose` is `true` in the `ts.createSolutionBuilder` function.
            const reportSolutionBuilderStatus = (diag) => {
                const msg = diag.messageText;
                this.logger.debug(msg);
            };
            const errorCounter = (errorCount) => {
                this.logger.info(`total error found: ${errorCount}`);
            };
            const host = this.tsModule.createSolutionBuilderHost(undefined, undefined, reportDiagnostic, reportSolutionBuilderStatus, errorCounter);
            yield this.writeProjectReferencesTsConfig(rootDir, capsuleDirs);
            const solutionBuilder = this.tsModule.createSolutionBuilder(host, [rootDir], { verbose: true });
            let nextProject;
            const longProcessLogger = this.logger.createLongProcessLogger('compile typescript components', capsules.length);
            // eslint-disable-next-line no-cond-assign
            while ((nextProject = solutionBuilder.getNextInvalidatedProject())) {
                // regex to make sure it will work correctly for both linux and windows
                // it replaces both /tsconfig.json and \tsocnfig.json
                const capsulePath = nextProject.project.replace(/[/\\]tsconfig.json/, '');
                const currentComponentId = capsules.getIdByPathInCapsule(capsulePath);
                if (!currentComponentId)
                    throw new Error(`unable to find component for ${capsulePath}`);
                longProcessLogger.logProgress(currentComponentId.toString());
                const capsule = capsules.getCapsule(currentComponentId);
                if (!capsule)
                    throw new Error(`unable to find capsule for ${currentComponentId.toString()}`);
                currentComponentResult.component = capsule.component;
                currentComponentResult.startTime = Date.now();
                nextProject.done(undefined, undefined, this.options.typescriptTransformers);
                currentComponentResult.endTime = Date.now();
                componentsResults.push(Object.assign({}, currentComponentResult));
                currentComponentResult = { errors: [] };
            }
            longProcessLogger.end();
            return componentsResults;
        });
    }
    getFormatDiagnosticsHost() {
        return {
            getCanonicalFileName: (p) => p,
            getCurrentDirectory: this.tsModule.sys.getCurrentDirectory,
            getNewLine: () => this.tsModule.sys.newLine,
        };
    }
    getDefaultGlobalTypes() {
        return (0, resolve_types_1.resolveTypes)(__dirname, ['global-types']);
    }
    writeTypes(dirs) {
        return __awaiter(this, void 0, void 0, function* () {
            const types = this.options.types || this.getDefaultGlobalTypes();
            yield Promise.all(types.map((typePath) => __awaiter(this, void 0, void 0, function* () {
                const contents = yield fs_extra_1.default.readFile(typePath, 'utf8');
                const filename = path_1.default.basename(typePath);
                yield Promise.all(dirs.map((dir) => __awaiter(this, void 0, void 0, function* () {
                    const filePath = path_1.default.join(dir, 'types', filename);
                    if (!(yield fs_extra_1.default.pathExists(filePath))) {
                        yield fs_extra_1.default.outputFile(filePath, contents);
                    }
                })));
            })));
        });
    }
    /**
     * when using project-references, typescript adds a file "tsconfig.tsbuildinfo" which is not
     * needed for the package.
     */
    writeNpmIgnore(dirs) {
        return __awaiter(this, void 0, void 0, function* () {
            const NPM_IGNORE_FILE = '.npmignore';
            yield Promise.all(dirs.map((dir) => __awaiter(this, void 0, void 0, function* () {
                const npmIgnorePath = path_1.default.join(dir, NPM_IGNORE_FILE);
                const npmIgnoreEntriesStr = `\n${this.distDir}/tsconfig.tsbuildinfo\n`;
                yield fs_extra_1.default.appendFile(npmIgnorePath, npmIgnoreEntriesStr);
            })));
        });
    }
    writeProjectReferencesTsConfig(rootDir, projects) {
        return __awaiter(this, void 0, void 0, function* () {
            const files = [];
            const references = projects.map((project) => ({ path: project }));
            const tsconfig = { files, references };
            const tsconfigStr = this.stringifyTsconfig(tsconfig);
            yield fs_extra_1.default.writeFile(path_1.default.join(rootDir, 'tsconfig.json'), tsconfigStr);
        });
    }
    writeTsConfig(dirs) {
        return __awaiter(this, void 0, void 0, function* () {
            const tsconfigStr = this.stringifyTsconfig(this.rawTsConfig);
            yield Promise.all(dirs.map((dir) => fs_extra_1.default.writeFile(path_1.default.join(dir, 'tsconfig.json'), tsconfigStr)));
        });
    }
    stringifyTsconfig(tsconfig) {
        return JSON.stringify(tsconfig, undefined, 2);
    }
    replaceFileExtToJs(filePath) {
        if (!this.isFileSupported(filePath))
            return filePath;
        const fileExtension = path_1.default.extname(filePath);
        return filePath.replace(new RegExp(`${fileExtension}$`), '.js'); // makes sure it's the last occurrence
    }
    version() {
        return this.tsModule.version;
    }
    static from(options) {
        return (context) => {
            const name = options.name || 'typescript-compiler';
            const logger = context.createLogger(name);
            const rawTsConfig = (0, get_ts_config_1.computeTsConfig)({
                tsconfig: options.tsconfig,
                compilerOptions: options.compilerOptions,
            });
            return new TypescriptCompiler(name, logger, options, rawTsConfig, options.typescript || typescript_1.default);
        };
    }
}
exports.TypescriptCompiler = TypescriptCompiler;
//# sourceMappingURL=typescript-compiler.js.map