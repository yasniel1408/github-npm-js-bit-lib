"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypescriptConfigWriter = exports.GLOBAL_TYPES_DIR = void 0;
const normalize_path_1 = __importDefault(require("normalize-path"));
const comment_json_1 = require("comment-json");
const utils_1 = require("@teambit/legacy/dist/utils");
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = require("path");
const lodash_1 = require("lodash");
const expand_include_exclude_1 = require("./expand-include-exclude");
const get_ts_config_1 = require("./get-ts-config");
const resolve_types_1 = require("./resolve-types");
const CONFIG_NAME = 'tsconfig.json';
const BIT_GENERATED_TS_CONFIG_COMMENT = '// bit-generated-typescript-config';
exports.GLOBAL_TYPES_DIR = 'global-types';
class TypescriptConfigWriter {
    constructor(name, tsconfig, typesPaths = [], logger) {
        this.name = name;
        this.tsconfig = tsconfig;
        this.typesPaths = typesPaths;
        this.logger = logger;
        this.id = 'typescript';
        this.patterns = [`**/${CONFIG_NAME}`];
    }
    calcConfigFiles(_executionContext, envMapValue, configsRootDir) {
        const tsConfigContent = JSON.stringify(this.tsconfig, null, 2);
        // It's important to calculate the hash before we call the expandIncludeExclude function
        // to make sure we get the same hash for the same config.
        // we will merge different include/exclude patterns to the same config file as part of the mergeConfigFiles
        // below
        const tsConfigHash = (0, utils_1.sha1)(tsConfigContent);
        const tsConfigName = `tsconfig.bit.${tsConfigHash}.json`;
        const tsConfigPath = (0, path_1.join)(configsRootDir, tsConfigName);
        const tsConfigCloned = JSON.parse(tsConfigContent);
        const compDirs = envMapValue.paths;
        const newTsConfig = (0, expand_include_exclude_1.expandIncludeExclude)(tsConfigPath, tsConfigCloned, compDirs, exports.GLOBAL_TYPES_DIR);
        const newTsConfigContent = JSON.stringify(newTsConfig, null, 2);
        const typescriptConfigFile = {
            content: newTsConfigContent,
            hash: tsConfigHash,
            name: tsConfigName,
        };
        const globalTypesConfigFiles = this.getGlobalTypesConfigFiles(this.typesPaths);
        return [typescriptConfigFile, ...globalTypesConfigFiles];
    }
    getGlobalTypesConfigFiles(typesPaths = []) {
        const files = typesPaths.map((path) => {
            const content = fs_extra_1.default.readFileSync(path).toString();
            const origName = (0, path_1.basename)(path);
            const nameWithHash = origName.replace(/\.d\.ts$/, '.{hash}.d.ts');
            const name = `${exports.GLOBAL_TYPES_DIR}/${nameWithHash}`;
            return {
                content,
                name,
            };
        });
        return files;
    }
    mergeConfigFiles(configFile, configFile2) {
        // Only merge tsconfig files (not global types for example)
        if (!configFile.name.includes('tsconfig.bit')) {
            return configFile.content;
        }
        const tsConfig1 = (0, comment_json_1.parse)(configFile.content);
        const tsConfig2 = (0, comment_json_1.parse)(configFile2.content);
        // @ts-ignore
        tsConfig1.include = (0, lodash_1.uniq)([...((tsConfig1 === null || tsConfig1 === void 0 ? void 0 : tsConfig1.include) || []), ...((tsConfig2 === null || tsConfig2 === void 0 ? void 0 : tsConfig2.include) || [])]).sort();
        // @ts-ignore
        tsConfig1.exclude = (0, lodash_1.uniq)([...((tsConfig1 === null || tsConfig1 === void 0 ? void 0 : tsConfig1.exclude) || []), ...((tsConfig2 === null || tsConfig2 === void 0 ? void 0 : tsConfig2.exclude) || [])]).sort();
        const content = (0, comment_json_1.stringify)(tsConfig1, null, 2);
        return content;
    }
    generateExtendingFile(args) {
        const { writtenConfigFiles } = args;
        const tsconfigFile = writtenConfigFiles.find((file) => file.name.includes('tsconfig.bit'));
        if (!tsconfigFile)
            return undefined;
        const config = {
            // Using DSL to make sure it will be replaced with relative path
            extends: `{${tsconfigFile.name}}`,
        };
        const content = `${BIT_GENERATED_TS_CONFIG_COMMENT}\n\n${JSON.stringify(config, null, 2)}`;
        return { content, name: 'tsconfig.json', extendingTarget: tsconfigFile, useAbsPaths: false };
    }
    postProcessExtendingConfigFiles(args) {
        return __awaiter(this, void 0, void 0, function* () {
            // @ts-ignore - ignore here is for backward compatibility as supportSpecificPathChange didn't exist in the past
            const { workspaceDir, configsRootDir, paths, extendingConfigFile, supportSpecificPathChange } = args;
            // Only run for the root tsconfig.json
            if (!paths.find((path) => path === '.')) {
                return undefined;
            }
            const { content } = extendingConfigFile;
            const tsConfig = (0, comment_json_1.parse)(content);
            // @ts-ignore
            const compilerOptions = tsConfig.compilerOptions || {};
            const typeRoots = compilerOptions.typeRoots || [];
            const globalTypesDir = (0, path_1.join)(configsRootDir, exports.GLOBAL_TYPES_DIR);
            const relativeGlobalTypesDir = (0, normalize_path_1.default)(`./${(0, path_1.relative)(workspaceDir, globalTypesDir)}`);
            typeRoots.push(relativeGlobalTypesDir);
            typeRoots.push('./node_modules/@types');
            (0, comment_json_1.assign)(compilerOptions, { typeRoots: (0, lodash_1.uniq)(typeRoots) });
            (0, comment_json_1.assign)(tsConfig, { compilerOptions });
            const newContent = (0, comment_json_1.stringify)(tsConfig, null, 2);
            if (supportSpecificPathChange) {
                // @ts-ignore - ignore here is for backward compatibility as this was invalid result type in old version
                return [{
                        path: '.',
                        content: newContent,
                    }];
            }
            // For backward compatibility
            return newContent;
        });
    }
    isBitGenerated(filePath) {
        const content = fs_extra_1.default.readFileSync(filePath).toString();
        return content.includes(BIT_GENERATED_TS_CONFIG_COMMENT);
    }
    static from(options) {
        const name = options.name || 'TypescriptConfigWriter';
        const handler = (context) => {
            return TypescriptConfigWriter.create(options, context.createLogger(name));
        };
        return {
            name,
            handler,
        };
    }
    static create(options, logger) {
        const name = options.name || 'TypescriptConfigWriter';
        const rawTsConfig = (0, get_ts_config_1.computeTsConfig)({
            tsconfig: options.tsconfig,
            compilerOptions: options.compilerOptions,
        });
        const types = options.types || (0, resolve_types_1.resolveTypes)(__dirname, ['global-types']);
        return new TypescriptConfigWriter(name, rawTsConfig, types, logger);
    }
}
exports.TypescriptConfigWriter = TypescriptConfigWriter;
//# sourceMappingURL=ts-config-writer.js.map